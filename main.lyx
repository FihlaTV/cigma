#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
raggedbottom
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
About Cigma
\end_layout

\begin_layout Standard
The CIG Model Analyzer (Cigma) is a program designed to compare general
 numerical models.
 In particular, Cigma will calculate the 
\begin_inset Formula $L_{2}$
\end_inset

-norm of the difference between finite element models, resulting in approximate
 global and local error metrics that may be used for both code verification
 and benchmarking purposes.
 
\end_layout

\begin_layout Standard
CIG developed Cigma in response to demand from the short-term tectonics
 community for an automated tool that can perform rigorous error analysis
 on their finite element codes.
 For example, on the cover of this manual is a 3D comparison for two resolutions
 of PyLith's reverse-slip benchmark problem 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/workinggroups/short/workarea/benchmarks/benchmark-rs-nog/desc
ription-rs-nog
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
By facilitating the process of data comparisons, independent of discretization,
 Cigma will better assist the Geodynamics community in their benchmarking
 activities.
 We also seek to increase confidence in the output of the CIG software by
 providing a standardized testing process.
 Such a process is vital to detecting critical errors during code development.
 For this purpose, Cigma is designed to be easily extensible.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://geodynamics.org/cig/workinggroups/short/workarea/benchmarks/benchmark-rs-n
og/description-rs-nog
\end_layout

\begin_layout Plain Layout
http://geodynamics.org/cig/software/packages/short/pylith/
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
PyLith itself is a finite element code for the solution of dynamic and quasi-sta
tic tectonic deformation problems.
\end_layout

\begin_layout Plain Layout
The benchmark problem being solved is a viscoelastic (Maxwell) relaxation
 of stresses from a single, finite, reverse-slip earthquake in 3D without
 gravity, with imposed displacement boundary conditions on a cube with sides
 of length 24 km.
 The displacements imposed are obtained via the analytic elastic solutions.
 Additionally, symmetry boundary conditions are imposed at 
\begin_inset Formula $y=0$
\end_inset

, so the solution is equivalent to that for a domain with a 48 km length
 in the 
\begin_inset Formula $y$
\end_inset

 direction.
 On the cover, we are visualizing the error in the displacement field between
 the 500m linear hexahedral, and 250m tetrahedral solution.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Citation
\end_layout

\begin_layout Standard
Computational Infrastructure for Geodynamics (CIG) is making this source
 code available to you in the hope that the software will enhance your research
 in geophysics.
 This is a brand-new code and at present no papers are published or in press.
 Please cite this manual as follows:
\end_layout

\begin_layout Itemize
Armendariz, L., and S.
 Kientz.
 
\emph on
Cigma User Manual.

\emph default
 Pasadena, CA: Computational Infrastructure of Geodynamics, 2008.
 URL: geodynamics.org/cig/software/cs/cigma/cigma.pdf
\end_layout

\begin_layout Standard
CIG requests that in your oral presentations and in your papers that you
 indicate your use of this code and acknowledge the author of the code and
 CIG 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Support
\end_layout

\begin_layout Standard
Cigma development is based upon work supported by the National Science Foundatio
n under Grant No.
 EAR-0406751.
 Any opinions, findings, and conclusions or recommendations expressed in
 this material are those of the authors and do not necessarily reflect the
 views of the National Science Foundation.
 The code is being released under the GNU General Public License v2.
\end_layout

\begin_layout Chapter
Installation and Getting Help
\end_layout

\begin_layout Section
Getting Help and Reporting Bugs
\end_layout

\begin_layout Standard
For help, send an e-mail to the CIG Computational Science Mailing List 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

cig-cs@geodynamics.org
\end_layout

\end_inset

.
 You can subscribe to the 
\family typewriter
cig-cs
\family default
 mailing list and view archived discussions at the CIG Mail Lists web page
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

geodynamics.org/cig/lists
\end_layout

\end_inset

.
 If you encounter any bugs or have problems installing Cigma, please submit
 a report to the CIG Bug Tracker 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

geodynamics.org/bugs
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Installing from Source
\end_layout

\begin_layout Standard
In this section we discuss how to install each of the software libraries
 necessary for building Cigma.
 We recommend that you obtain binaries for these dependencies from your
 package manager of choice, or when available from the corresponding websites.
 When using a package manager, you will have to make sure to install any
 associated development packages, as these tend to be distributed separately
 from the library packages themselves.
\end_layout

\begin_layout Subsection
Quick Summary
\end_layout

\begin_layout Standard
After installing the necessary dependencies described below, download the
 source package from the CIG Cigma web page 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/software/packages/cs/cigma
\end_layout

\end_inset

.
 You will need the GNU C++ compiler for this step.
 Unpack the source tar file and issue the following commands
\end_layout

\begin_layout LyX-Code
$ tar xvfz cigma-1.0.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd cigma-1.0.0
\end_layout

\begin_layout LyX-Code
$ ./configure 
\backslash

\end_layout

\begin_layout LyX-Code
    --with-boost=
\emph on
$BOOST_PREFIX
\emph default
      
\backslash

\end_layout

\begin_layout LyX-Code
    --with-hdf5=
\emph on
$HDF5_PREFIX
\emph default
        
\backslash

\end_layout

\begin_layout LyX-Code
    --with-vtk=
\emph on
$VTK_PREFIX
\emph default
          
\backslash

\end_layout

\begin_layout LyX-Code
    --with-vtk-version=
\emph on
$VTK_VERSION
\emph default
 
\backslash

\end_layout

\begin_layout LyX-Code
    --with-netcdf=
\emph on
$NETCDF_PREFIX
\emph default
    
\backslash

\end_layout

\begin_layout LyX-Code
    --with-cppunit-prefix=
\emph on
$CPPUNIT_PREFIX
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
In general, the installation prefixes given to the configure options should
 be used if you have installed the corresponding library in a custom location,
 but may otherwise be omitted if the prefix is one of the default system
 directories, such as 
\family typewriter
/usr
\family default
 or 
\family typewriter
/usr/local
\family default
.
 For demonstration purposes, the instructions in the next few sections use
 a subdirectory of 
\family typewriter
$HOME/opt
\family default
 as the installation prefix for each of the dependencies.
\end_layout

\begin_layout Standard
The only required options in this step are the ones for the Boost and HDF5
 libraries.
 If you wish to enable VTK library support, you will also have to select
 a specific version number by providing the configure flag 
\family typewriter
--with-vtk-version
\family default
, whose value defaults to 
\begin_inset Quotes eld
\end_inset


\family typewriter
5.0
\family default

\begin_inset Quotes erd
\end_inset

.
 The NetCDF option is disabled by default, but if you wish to use ExodusII
 mesh files, you can provide an installation prefix to the corresponding
 configure option.
 Lastly, the CppUnit configure option will allow you to use 
\family typewriter
make check
\family default
 to compile and run a basic set of unit tests which verify that Cigma is
 giving internally consistent results.
\end_layout

\begin_layout Standard
After all these steps are complete, you should be able to run the 
\family typewriter
cigma
\family default
 binary and proceed to compare your data files.
\end_layout

\begin_layout Subsection
Boost library
\end_layout

\begin_layout Standard
The Boost C++ libraries are a collection of peer-reviewed and open source
 libraries that extend the functionality of C++.
 Cigma uses Boost for its smart pointer facilities, lexical conversions,
 as well as for parsing command-line options, and for providing cross-platform
 filesystem operations.
 If Boost is not available for your platform as a binary package that can
 be readily installed, you may choose to install Boost with only the components
 that Cigma will need,
\end_layout

\begin_layout LyX-Code
$ tar xvfz boost_1_37_0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd boost_1_37_0
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/boost 
\backslash

\end_layout

\begin_layout LyX-Code
              --with-libraries=system,filesystem,program_options
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
Just as a reference, the full list of Boost components can be obtained with
 the command
\end_layout

\begin_layout LyX-Code
$ ./configure --show-libraries
\end_layout

\begin_layout Standard
Enabling all components will certainly increase the compilation time of
 the Boost code, since some of those components will require compilation.
\end_layout

\begin_layout Subsection
HDF5 library
\end_layout

\begin_layout Standard
The Hierarchical Data Format is a library and multi-object file format for
 the transfer of numerical data between computers.
 Since Cigma depends on the C++ API of the HDF5 library, it is important
 to enable C++ support when running the configure script below.
 We recommend you install the library version 1.8 or higher, due to the improved
 metadata API in those versions.
 The latest source can be obtained from The HDF Group 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

hdfgroup.org/HDF5
\end_layout

\end_inset

, and it uses the following sequence of commands to build the library.
 
\end_layout

\begin_layout LyX-Code
$ tar xvfz hdf5-1.8.2.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd hdf5-1.8.2
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/hdf5-1.8.2 
\backslash

\end_layout

\begin_layout LyX-Code
              --with-zlib=$ZLIB_PREFIX      
\backslash

\end_layout

\begin_layout LyX-Code
              --enable-cxx
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
In the rare case that the zlib compression library is not already available
 on your system, you must install it before running the installation procedure
 given above, 
\end_layout

\begin_layout LyX-Code
$ tar xvfz zlib-1.2.3.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd zlib-1.2.3
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/hdf5-1.8.2
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
In practice, you only need to do this if your system is missing the zlib
 development headers and you are unable to install them otherwise.
\end_layout

\begin_layout Standard
Alternatively, compiled binaries for the HDF5 library can be obtained at
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

hdfgroup.org/HDF5/release/obtain5.html
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
VTK library (optional)
\end_layout

\begin_layout Standard
The Visualization Toolkit (VTK) library is a popular open source graphics
 library for scientific visualizations.
 Cigma will need to be configured with the VTK library if you plan to directly
 specify your functions by using the VTK file format.
 The source for the VTK library is available from Kitware, Inc.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.vtk.org/get-software.php
\end_layout

\end_inset

.
 You will also need the CMake build environment, available from CMake 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

cmake.org
\end_layout

\end_inset

.
 After downloading the source package for the VTK library, you can issue
 the following commands
\end_layout

\begin_layout LyX-Code
$ tar xvfz vtk-5.2.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd VTK
\end_layout

\begin_layout LyX-Code
$ mkdir build
\end_layout

\begin_layout LyX-Code
$ cd build
\end_layout

\begin_layout LyX-Code
$ ccmake ..
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
The installation prefix and other settings can be changed during the 
\family typewriter
ccmake
\family default
 step above.
 By default, the installation prefix will point to the 
\family typewriter
/usr/local
\family default
 directory, but you may want to change it to a location like 
\family typewriter
$HOME/opt/vtk-5.2
\family default
 in case you would like to manage multiple versions of the VTK library in
 the same system.
\end_layout

\begin_layout Subsection
NetCDF library (optional)
\end_layout

\begin_layout Standard
NetCDF (Network Common Data Form) is a set of software libraries and machine-ind
ependent data formats that support the creation, access, and sharing of
 array-oriented scientific data.
 The source for NetCDF can be obtained from Unidata 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.unidata.ucar.edu/software/netcdf/
\end_layout

\end_inset

.
\end_layout

\begin_layout LyX-Code
$ tar xvfz netcdf-4.0
\end_layout

\begin_layout LyX-Code
$ cd netcdf-4.0
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/netcdf-4.0    
\backslash

\end_layout

\begin_layout LyX-Code
              --with-hdf5=$HOME/opt/hdf5-1.8.2 
\backslash

\end_layout

\begin_layout LyX-Code
              --enable-netcdf-4
\end_layout

\begin_layout LyX-Code
              
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
Using this library is optional, so it is not automatically detected at configure
 time.
 NetCDF support in Cigma is still experimental, and is currently only intended
 for reading ExodusII mesh files created through the CUBIT mesh generator.
 Only the first element block will be used, so that the corresponding Cigma
 mesh object will consist of a single element type.
\end_layout

\begin_layout Subsection
CppUnit library (optional)
\end_layout

\begin_layout Standard
CppUnit is a C++ unit testing framework used by Cigma for automatically
 running various internal consistency checks during every build.
 You will need this library if you want to modify the Cigma source and want
 to make certain guarantees about your additions to the code.
 After obtaining the latest source release, you may build CppUnit by using
 the following sequence of steps:
\end_layout

\begin_layout LyX-Code
$ tar xvfz cppunit-1.21.1.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd cppunit-1.21.1
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/cppunit-1.21.1
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
CppUnit is available for download from its SourceForge project site 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

sourceforge.net/projects/cppunit/
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsection
Compiling Cigma
\end_layout

\begin_layout Standard
After carefully following the instructions above, we should be able to install
 Cigma using this set of commands:
\end_layout

\begin_layout LyX-Code
$ tar xvfz cigma-1.0.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd cigma-1.0.0
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/cigma-1.0.0 
\backslash

\end_layout

\begin_layout LyX-Code
      --with-boost=$HOME/opt/boost 
\backslash

\end_layout

\begin_layout LyX-Code
      --with-hdf5=$HOME/opt/hdf5-1.8.2 
\backslash

\end_layout

\begin_layout LyX-Code
      --with-vtk=$HOME/opt/vtk-5.2.0 
\backslash

\end_layout

\begin_layout LyX-Code
      --with-vtk-version=5.2 
\backslash

\end_layout

\begin_layout LyX-Code
      --with-cppunit-prefix=$HOME/opt/cppunit-1.21.1
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make check
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
These instructions have used custom installation locations, so it is also
 necessary to update the 
\family typewriter
PATH
\family default
 and 
\family typewriter
LD_LIBRARY_PATH
\family default
 environment variables.
 Preferably you should update these environment variables in your shell
 login file, but you can also update them on the command line itself.
 Here we show the appropriate set of commands for a bash shell session.
\end_layout

\begin_layout LyX-Code
$ PATH=
\begin_inset Quotes erd
\end_inset

$PATH:$HOME/opt/cigma-1.0.0/bin
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ PATH=
\begin_inset Quotes erd
\end_inset

$PATH:$HOME/opt/hdf5-1.8.2/bin
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ export PATH
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
$ LD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/boost/lib:$LD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ LD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/hdf5-1.8.2/lib:$LD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ LD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/vtk-5.2.0/lib:$LD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ export LD_LIBRARY_PATH
\end_layout

\begin_layout Standard
On Mac OS X, you will also need to update the 
\family typewriter
DYLD_LIBRARY_PATH
\family default
 environment variable,
\end_layout

\begin_layout LyX-Code
$ DYLD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/boost/lib:$DYLD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ DYLD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/hdf5-1.8.2/lib:$DYLD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ DYLD_LIBRARY_PATH=
\begin_inset Quotes erd
\end_inset

$HOME/opt/vtk-5.2.0/lib:$DYLD_LIBRARY_PATH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
$ export DYLD_LIBRARY_PATH
\end_layout

\begin_layout Standard
No environment variables need to be set if all installation prefixes use
 a system directory.
\end_layout

\begin_layout Section
Installing from the Software Repository
\end_layout

\begin_layout Standard
The Cigma source code is available via the CIG Subversion Repository 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/software/Repository
\end_layout

\end_inset

.
 For this section, you will need a Subversion client, as well as the GNU
 tools Autoconf, Automake, and Libtool.
 To check if you have a Subversion client installed, type 
\family typewriter
svn
\family default
 and look for a usage message
\end_layout

\begin_layout LyX-Code
$ svn
\end_layout

\begin_layout LyX-Code
Type 'svn help' for usage.
\end_layout

\begin_layout Standard
To check for the presence of the GNU Autotools, use the following commands:
\end_layout

\begin_layout LyX-Code
$ autoconf --version
\end_layout

\begin_layout LyX-Code
$ automake --version
\end_layout

\begin_layout LyX-Code
$ libtoolize --version
\end_layout

\begin_layout Standard
Using the source repository directly is recommended for users who want to
 extend Cigma.
\end_layout

\begin_layout Subsection
Downloading the Cigma Source
\end_layout

\begin_layout Standard
You may check out the latest version of Cigma by using the 
\family typewriter
svn checkout
\family default
 command:
\end_layout

\begin_layout LyX-Code
$ svn checkout http://geodynamics.org/svn/cig/cs/cigma/trunk cigma
\end_layout

\begin_layout Standard
This will create the local directory 
\family typewriter
cigma
\family default
 and fill it with the latest Cigma source from the CIG software repository.
 This new directory is called a 
\emph on
working copy
\emph default
.
 To merge the latest changes into your working copy, use the 
\family typewriter
svn update
\family default
 command:
\end_layout

\begin_layout LyX-Code
$ cd cigma
\end_layout

\begin_layout LyX-Code
$ svn update
\end_layout

\begin_layout Standard
This will preserve any local changes you have made to your working copy.
\end_layout

\begin_layout Subsection
Using the GNU Build System
\end_layout

\begin_layout Standard
Once you have obtained a working copy of the Cigma source, you will need
 to use the GNU Autotools to generate the appropriate build files.
 This can be accomplished by running the command 
\family typewriter
autoreconf -fi
\family default
:
\end_layout

\begin_layout LyX-Code
$ cd cigma
\end_layout

\begin_layout LyX-Code
$ autoreconf -fi
\end_layout

\begin_layout Standard
The 
\family typewriter
autoreconf
\family default
 tool generates the 
\family typewriter
configure
\family default
 script from the 
\family typewriter
configure.ac
\family default
 file.
 It also runs Automake to generate 
\family typewriter
Makefile.in
\family default
 from 
\family typewriter
Makefile.am
\family default
 in each source directory.
 After running 
\family typewriter
autoreconf
\family default
, you may configure, build, and install Cigma as described in Section 2.2.
\end_layout

\begin_layout Chapter
Error Analysis
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "cha:Error-Analysis"

\end_inset

Error Analysis
\end_layout

\begin_layout Standard
When solving differential equations representing physical systems of interest,
 we are often able to obtain a family of solutions by applying a variety
 of solution techniques.
 Sometimes an analytic method can be found, but most of the time we end
 up resorting to a numerical algorithm, such as the finite element method.
 Assessing the quality of these solutions is an important task, so we would
 like to develop a quantitative measure for indicating just how close our
 solutions approach the exact answer.
\end_layout

\begin_layout Standard
The simplest possible quantitative measure of the difference between two
 distinct functions consists of taking the pointwise difference at a common
 set of points.
 While no finite sample of points can perfectly represent a continuum of
 values, valuable information can be inferred from the statistics of the
 resulting set of differences.
 However, the functions we want to compare may not be defined at a common
 set of points.
 Unless we are able to interpolate the two functions on an intermediate
 set of points, this simple pointwise measure becomes inapplicable.
\end_layout

\begin_layout Standard
A very useful distance measure we can use is the 
\begin_inset Formula $L_{2}$
\end_inset

 norm, defined by the following integral
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\varepsilon=||u-v||_{L_{2}}=\sqrt{\int_{\Omega}||u(\vec{x})-v(\vec{x})||^{2}d\vec{x}}\end{equation}

\end_inset

where 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are the two functions defined on a global coordinate system.
 This gives us a single global estimate 
\begin_inset Formula $\varepsilon$
\end_inset

 representing the distance between the two functions 
\begin_inset Formula $u(\vec{x})$
\end_inset

 and 
\begin_inset Formula $v(\vec{x})$
\end_inset

.
 Alternatively, you may think of this as the size, or norm, of the 
\series bold
\emph on
error field
\series default
\emph default
 
\begin_inset Formula $\rho(\vec{x})=u(\vec{x})-v(\vec{x})$
\end_inset

.
 This measure is useful because it is well known that solutions obtained
 with the finite element method converge only in a weak sense, as an average
 over a geometric region.
 In the rest of this chapter we will discuss the details involved in evaluating
 the above integral.
\end_layout

\begin_layout Standard
Another quantitative measure, which we won't discuss in this version of
 Cigma, is the energy norm.
 This norm is typically employed in 
\emph on
a posteriori
\emph default
 error analysis and is problem dependent.
 In general, the error field used under this norm is defined in terms of
 the linearized equation from which the solution was obtained, instead of
 directly subtracting the corresponding function values.
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
The functions that we discuss in this manual are assumed to be defined in
 a common region of space which we denote by 
\begin_inset Formula $\Omega$
\end_inset

.
 Elements of 
\begin_inset Formula $\Omega$
\end_inset

 are written as 
\begin_inset Formula $\vec{x}$
\end_inset

, and the number of components in the corresponding value of 
\begin_inset Formula $f(\vec{x})$
\end_inset

, is said to be the 
\series bold
\emph on
rank
\series default
\emph default
 of the function 
\begin_inset Formula $f$
\end_inset

.
 Thus, 
\emph on
scalar functions
\emph default
 have a rank of 1, while 
\emph on
vector functions
\emph default
 usually have a rank of either 2 or 3.
\end_layout

\begin_layout Section
Integral Approximations
\end_layout

\begin_layout Standard
In order to evaluate the integral for our 
\begin_inset Formula $L_{2}$
\end_inset

 norm, we will need to define an integration mesh which partitions the common
 domain 
\begin_inset Formula $\Omega$
\end_inset

 on which our two functions are defined.
 We can then use a numerical approximation, or 
\series bold
\emph on
integration rule
\series default
\emph default
, on each of the discrete cell elements 
\begin_inset Formula $\Omega_{i}$
\end_inset

 of our partition.
 Each of these cell integrals of the continuous error norm 
\begin_inset Formula $||\rho(\vec{x})||^{2}$
\end_inset

 can then be replaced by a weighed sum evaluated at a finite set of points.
 This integral will be valid up to a certain accuracy.
 In later chapters, we will discuss in more detail how to choose the location
 and values for the integration points and weights which give optimal accuracy.
\end_layout

\begin_layout Standard
In general, an integration rule with 
\begin_inset Formula $Q$
\end_inset

 points and weights that allows us to integrate the scalar function 
\begin_inset Formula $F(\vec{x})$
\end_inset

 is given by the equation
\begin_inset Formula \begin{equation}
\int_{\Omega_{i}}\ F(\vec{x})\ d\vec{x}\approx\sum_{q=1}^{Q}F(\vec{X_{q}})W_{q}\end{equation}

\end_inset

where the integration points 
\begin_inset Formula $\vec{X}_{q}$
\end_inset

 and integration weights 
\begin_inset Formula $W_{q}$
\end_inset

 depend on the integration region 
\begin_inset Formula $\Omega_{i}$
\end_inset

.
 One possibility is to pre-calculate these points and weights explicitly
 on a specific discretization.
 We will generally want to define a reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 which acts as a template for all cells with the same geometric shape.
 We can achieve this by defining a 
\series bold
\emph on
reference map
\series default
\emph default
 
\begin_inset Formula $\chi_{i}:\hat{\Omega}\to\Omega_{i}$
\end_inset

 that describes how points in a specific cell 
\begin_inset Formula $\Omega_{i}$
\end_inset

 originate from the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 In this sense, the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 is said to define a 
\series bold
\emph on
local coordinate system
\series default
\emph default
 for the 
\begin_inset Formula $i$
\end_inset

-th cell 
\begin_inset Formula $\Omega_{i}.$
\end_inset


\end_layout

\begin_layout Standard
Note that a given discretization may contain cells of different shapes,
 which would require us to define an appropriate number of reference cells
 for each type of cell.
 However, we may restrict the discussions in this manual to discretizations
 consisting of a single geometric shape without any loss of generality.
\end_layout

\begin_layout Standard
The advantage of this approach is readily apparent when one realizes that
 the integration points and weights can be calculated once and for all on
 the reference cell, and then reused for the other cells through the application
 of the corresponding reference map.
 In other words,
\begin_inset Formula \begin{eqnarray}
\vec{X}_{q} & = & \chi_{i}(\vec{\xi}_{q})\\
W_{q} & = & w_{q}J_{i}(\vec{\xi}_{q})\end{eqnarray}

\end_inset

where 
\begin_inset Formula $\vec{\xi}_{q}$
\end_inset

 and 
\begin_inset Formula $w_{q}$
\end_inset

 are the optimal integration points and weights for the integration rule
 defined on the reference domain 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 Here, the factor 
\begin_inset Formula $J_{i}(\vec{\xi})=\det\ \left|\frac{d\chi_{i}}{d\vec{\xi}}\right|$
\end_inset

 is the Jacobian determinant of the transformation 
\begin_inset Formula $\chi_{i}$
\end_inset

.
 Recall that the index 
\begin_inset Formula $i$
\end_inset

 corresponds to the 
\begin_inset Formula $i$
\end_inset

-th cell 
\begin_inset Formula $\Omega_{i}$
\end_inset

, and the index 
\begin_inset Formula $q$
\end_inset

 ranges over the usual 
\begin_inset Formula $q=1,\ldots,Q$
\end_inset

.
\end_layout

\begin_layout Section
Interpolation Functions
\end_layout

\begin_layout Standard
Our two functions 
\begin_inset Formula $u(\vec{x})$
\end_inset

 and 
\begin_inset Formula $v(\vec{x})$
\end_inset

 are given in terms of the point 
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

, and are said to be defined on a 
\series bold
\emph on
global coordinate system
\series default
\emph default
.
 Based on our discussion in Section 3.1, we see that we only need to know
 the values of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 at a finite set of global points in order to calculate an approximation
 to the 
\begin_inset Formula $L_{2}$
\end_inset

 norm of the error field 
\begin_inset Formula $\rho=u-v$
\end_inset

.
\end_layout

\begin_layout Standard
Specifically, given a function 
\begin_inset Formula $f(\vec{x})$
\end_inset

 we must be able to calculate its values at exactly those integration points.
 If we know a formula or algorithm for 
\begin_inset Formula $f$
\end_inset

, then our task is easy.
 Alternatively, these values can be given explicitly as a finite list.
 In all other cases, we will need an interpolation scheme that allows us
 to calculate 
\begin_inset Formula $f$
\end_inset

 on any intermediate points.
 This ability is also important because we may want to increase the accuracy
 of our norm by using more integration points, and thus we will need to
 be able to evaluate our function 
\begin_inset Formula $f$
\end_inset

 at the new points.
\end_layout

\begin_layout Standard
In general, an interpolation scheme involves a set of known functions 
\begin_inset Formula $\phi_{j}(\vec{x})$
\end_inset

 that we can compute anywhere and a set of parameters 
\begin_inset Formula $c_{j}$
\end_inset

 that define how these known functions are combined.
 Usually, the relation between the parameters and the known functions is
 a linear combination, 
\begin_inset Formula \begin{equation}
f(\vec{x})=d_{1}\phi_{1}(\vec{x})+d_{2}\phi_{2}(\vec{x})+\cdots+d_{m}\phi_{m}(\vec{x})\end{equation}

\end_inset

where the parameters 
\begin_inset Formula $d_{j}$
\end_inset

, with 
\begin_inset Formula $j=1,\ldots,m$
\end_inset

, are also sometimes referred to as the 
\series bold
\emph on
degrees of freedom
\series default
\emph default
 of the function 
\begin_inset Formula $f$
\end_inset

.
 As described in Chapter 4, the functions 
\begin_inset Formula $\phi_{j}$
\end_inset

, also known as 
\series bold
\emph on
shape functions
\series default
\emph default
, must satisfy a number of conditions.
 Because the choice of shape functions affects how well the true solution
 is represented, the convergence of the numerical method used to obtain
 the solution, the optimal choice of shape functions is very problem dependent.
\end_layout

\begin_layout Standard
If we know the shape functions 
\begin_inset Formula $\phi_{j}$
\end_inset

 directly in terms of the global points 
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

, they are said to form a 
\series bold
\emph on
global interpolation scheme
\series default
\emph default
, and we may use Eq.
 3.3 directly to find the values of 
\begin_inset Formula $f(\vec{x})$
\end_inset

, and we may refer to the 
\begin_inset Formula $\phi_{j}$
\end_inset

 as 
\emph on
global shape functions
\emph default
.
 Note that since we are working in the global coordinate system, we don't
 need the discretization of the domain 
\begin_inset Formula $\Omega$
\end_inset

.
 An example of global shape functions would be the spherical harmonic functions.
\end_layout

\begin_layout Standard
Perhaps a more typical case is when 
\begin_inset Formula $f(\vec{x})$
\end_inset

 is defined piecewise, on each discretization element 
\begin_inset Formula $\Omega_{i}$
\end_inset

.
 Because these cells partition the original domain by definition, a given
 point in our domain will be found in one and only one cell, which will
 have a local definition.
 That is, for a particular 
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

 we will be able to find a unique cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

, for some index 
\begin_inset Formula $e$
\end_inset

.
 We can refer to this as a 
\series bold
\emph on
local interpolation scheme
\series default
\emph default
.
\end_layout

\begin_layout Standard
Refer to the Appendix for more details on the specific interpolation schemes
 available in Cigma.
\end_layout

\begin_layout Section
Global Error Measure
\end_layout

\begin_layout Standard
In this section we discuss the underlying formula used by Cigma to compute
 the 
\begin_inset Formula $L_{2}$
\end_inset

 norm of the error field 
\begin_inset Formula $\rho$
\end_inset

.
\end_layout

\begin_layout Standard
Suppose the domain 
\begin_inset Formula $\Omega$
\end_inset

 is partitioned into an appropriate set of cells 
\begin_inset Formula $\Omega_{1},\Omega_{2},\ldots,\Omega_{n_{el}}$
\end_inset

.
 We can then compute the global error 
\begin_inset Formula $\varepsilon^{2}$
\end_inset

 as a sum over localized cell contributions, 
\begin_inset Formula $\varepsilon^{2}=\sum_{e}\varepsilon_{e}^{2}$
\end_inset

, where each cell error 
\begin_inset Formula $\varepsilon_{e}^{2}$
\end_inset

 is given by
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\varepsilon_{e}^{2} & = & \int_{\Omega_{e}}||u(\vec{x})-v(\vec{x})||^{2}d\vec{x}\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
In general, we won't be able to integrate each cell error 
\begin_inset Formula $\varepsilon_{e}^{2}$
\end_inset

 exactly since either of the functions 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 may have an incompatible representation relative to the finite element
 space on each domain 
\begin_inset Formula $\Omega_{e}$
\end_inset

.
 However, we can still calculate an approximation of each cell error by
 applying an appropriate quadrature rule with a tolerable truncation error
 
\begin_inset CommandInset citation
LatexCommand cite
key "Cools 2003"

\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain an approximation to the integral of a function 
\begin_inset Formula $F(\vec{x})$
\end_inset

 over a cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

, we simply apply the quadrature rule with weights 
\begin_inset Formula $w_{e,1},w_{e,2},\ldots,w_{e,n_{Q}}$
\end_inset

 and integration points 
\begin_inset Formula $\vec{x}_{e,1},\vec{x}_{e,2},\ldots,\vec{x}_{e,n_{Q}}$
\end_inset

 appropriate for the physical element 
\begin_inset Formula $\Omega_{e}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\int_{\Omega_{e}}\ F(\vec{x})\ d\vec{x}=\sum_{q=1}^{n_{Q}}w_{e,q}F(\vec{x}_{e,q})\label{eq:}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Applying this quadrature rule directly over the entire physical domain 
\begin_inset Formula $\Omega=\cup\Omega_{e}$
\end_inset

 gives us 
\begin_inset Formula \begin{equation}
\int_{\Omega}\ F(\vec{x})\ d\vec{x}=\sum_{e=1}^{n_{el}}\sum_{q=1}^{n_{Q}}w_{e,q}F(\vec{x}_{e,q})\label{eq:-1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
For efficiency reasons, it is undesirable in finite element applications
 to perform calculations in a global coordinate system.
 To avoid duplication of work, shape function evaluations may be performed
 once on a reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 and then transformed back into the corresponding physical cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

 as needed.
\end_layout

\begin_layout Standard
To compute integrals of 
\begin_inset Formula $F$
\end_inset

 in a reference coordinate system, we need to apply a change of variables:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\int_{\Omega_{e}}\ F(\vec{x})\ d\vec{x}=\int_{\hat{\Omega}}\ F(\vec{x}_{e}(\vec{\xi}))J_{e}(\vec{\xi})\ d\vec{\xi}\label{eq:-2}\end{equation}

\end_inset

where 
\color none
the additional factor 
\begin_inset Formula $J_{e}(\vec{\xi})=\det\left[\frac{d\vec{x}_{e}}{d\vec{\xi}}\right]$
\end_inset

 is the Jacobian determinant of the reference map 
\begin_inset Formula $\vec{x}_{e}(\vec{\xi}):\hat{\Omega}\to\Omega_{e}$
\end_inset

.
 This map describes how the physical points 
\begin_inset Formula $\vec{x}\in\Omega_{e}$
\end_inset

 are transformed from the reference points 
\begin_inset Formula $\vec{\xi}\in\hat{\Omega}$
\end_inset

.
 Put another way, the inverse reference map 
\color inherit

\begin_inset Formula $\vec{\xi}=\vec{x}_{e}^{-1}(\vec{x})$
\end_inset

 tells us how the physical domain 
\begin_inset Formula $\Omega_{e}$
\end_inset

 maps into the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
\end_layout

\begin_layout Standard
At this point, we can assume without loss of generality that every physical
 cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

 can be derived from a single reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

, so that our quadrature rule becomes simply a set of weights 
\begin_inset Formula $w_{1},\ldots,w_{n_{Q}}$
\end_inset

 and points 
\begin_inset Formula $\vec{\xi}_{1},\ldots,\vec{\xi}_{n_{Q}}$
\end_inset

 over 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 After changing variables, we end up with the final form of the quadrature
 rule that we can use to integrate the global error field:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\int_{\hat{\Omega}}\ F(\vec{x}_{e}(\vec{\xi}))J_{e}(\vec{\xi})\ d\vec{\xi}=\sum_{q=1}^{n_{Q}}w_{q}F(\vec{x}_{e}(\vec{\xi}_{q}))J_{e}(\vec{\xi}_{q})\label{eq:-3}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
If we let 
\begin_inset Formula $F(\vec{x})=||u(\vec{x})-v(\vec{x})||^{2}$
\end_inset

 in the above expression, we can find the cell error contribution over 
\begin_inset Formula $\Omega_{e}$
\end_inset

 from
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\varepsilon_{e}^{2} & = & \int_{\Omega_{e}}\ ||u(\vec{x})-v(\vec{x})||^{2}\ d\vec{x}\nonumber \\
 & = & \int_{\hat{\Omega}}\ ||u(\vec{x}_{e}(\vec{\xi}))-v(\vec{x}_{e}(\vec{\xi}))||^{2}J_{e}(\vec{\xi})\ d\vec{\xi}\nonumber \\
 & = & \sum_{q=1}^{\mathrm{n_{Q}}}||u(\vec{x}_{e}(\vec{\xi}_{q}))-v(\vec{x}_{e}(\vec{\xi}_{q}))||^{2}w_{q}J_{e}(\vec{\xi}_{q})\label{eq:cell-residual}\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
The global error 
\begin_inset Formula $\varepsilon=\sqrt{\sum_{e}\varepsilon_{e}^{2}}$
\end_inset

 is then approximated by the expression
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula \begin{eqnarray}
\varepsilon & = & \sqrt{\sum_{e=1}^{\mathrm{n_{el}}}\sum_{q=1}^{\mathrm{n_{Q}}}||u(\vec{x}_{e}(\vec{\xi}_{q}))-v(\vec{x}_{e}(\vec{\xi}_{q}))||^{2}w_{q}J_{e}(\vec{\xi}_{q})}\end{eqnarray}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
We use this final form to calculate the global and localized errors on arbitrary
 discretizations.
\end_layout

\begin_layout Section
Comparing Global Error Quantities
\end_layout

\begin_layout Standard
Since the absolute magnitude of the 
\begin_inset Formula $L_{2}$
\end_inset

-norm is typically not important, you may want to normalize it relative
 to another computable global quantity, to make comparisons easier.
 One possibility would be to normalize the global error by the norm of the
 exact solution.
 For a family of solutions 
\begin_inset Formula $u_{h}(\vec{x})$
\end_inset

, parametrized by the maximum element size 
\begin_inset Formula $h$
\end_inset

 of the underlying discretization, and an exact solution 
\begin_inset Formula $u(\vec{x})$
\end_inset

, this normalized error is given by
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\varepsilon_{rel} & = & \frac{||u-u_{h}||_{L_{2}}}{||u||_{L_{2}}}\nonumber \\
 & = & \frac{\int_{\Omega}||u(\vec{x})-u_{h}(\vec{x})||^{2}d\vec{x}}{\int_{\Omega}||u(\vec{x})||^{2}d\vec{x}}\end{eqnarray}

\end_inset

Alternatively, we can normalize the global error using the total volume
 of the domain
\begin_inset Formula \begin{eqnarray}
\varepsilon_{abs} & = & \frac{||u-u_{h}||_{L_{2}}}{\sqrt{V}}\nonumber \\
 & = & \frac{\sqrt{\int_{\Omega}||u(\vec{x})-u_{h}(\vec{x})||^{2}d\vec{x}}}{\sqrt{\int_{\Omega}d\vec{x}}}\end{eqnarray}

\end_inset

which is the normalization that Cigma uses by default.
\end_layout

\begin_layout Standard
This normalized error can be interpreted as the average error in the physical
 quantity being evaluated, so that a value of 0.01 corresponds to a 1% averaged
 error, in absolute units.
 Even if the exact solution is not currently known, this normalized error
 may be used to test the accuracy between two or more numerical solutions,
 defined on successively refined meshes.
\end_layout

\begin_layout Section
Convergence Rates
\end_layout

\begin_layout Standard
Once we have calculated a family of solutions 
\begin_inset Formula $u_{h}(\vec{x})$
\end_inset

 on a family of increasingly refined meshes 
\begin_inset Formula $\Omega_{h}$
\end_inset

, where 
\begin_inset Formula $h$
\end_inset

 is a parameter denoting the size of the largest element in the corresponding
 mesh 
\begin_inset Formula $\Omega_{h}$
\end_inset

, we may estimate how fast we are converging to the analytic solution 
\begin_inset Formula $u(\vec{x})$
\end_inset

 by using the standard error estimate 
\begin_inset Formula $||u-u_{h}||_{p}\leq Ch^{\alpha},$
\end_inset

 where 
\begin_inset Formula $C$
\end_inset

 is a constant independent of both 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

.
 This error bound holds for a wide range of problems and may be used for
 estimating the convergence rate 
\begin_inset Formula $\alpha$
\end_inset

.
 If the analytic solution 
\begin_inset Formula $u$
\end_inset

 is unknown, one may use in its place the highest-accuracy solution available.
 In that case, the value of 
\begin_inset Formula $h$
\end_inset

 you should use would correspond to the lower-accuracy solution against
 which you are comparing.
\end_layout

\begin_layout Standard
For a single refinement level we have two discretizations 
\begin_inset Formula $\Omega_{1}$
\end_inset

 and 
\begin_inset Formula $\Omega_{2}$
\end_inset

, along with the corresponding solutions 
\begin_inset Formula $u_{1}$
\end_inset

 and 
\begin_inset Formula $u_{2}$
\end_inset

.
 The convergence rate can then be estimated from the two approximate bounds
 
\begin_inset Formula \begin{eqnarray}
\varepsilon_{1} & \sim & Ch_{1}^{\alpha}\\
\varepsilon_{2} & \sim & Ch_{2}^{\alpha}\end{eqnarray}

\end_inset

by taking their ratio and solving for 
\begin_inset Formula $\alpha$
\end_inset

, giving us the equation 
\begin_inset Formula \begin{equation}
\alpha\sim\frac{\log(\varepsilon_{2}/\varepsilon_{1})}{\log(h_{2}/h_{1})}\label{eq:ratio-alpha}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
If solutions are available for several refinement levels 
\begin_inset Formula $\Omega_{i}$
\end_inset

, we can estimate 
\begin_inset Formula $\alpha$
\end_inset

 by performing linear regression analysis on the equation
\begin_inset Formula \begin{equation}
\log\varepsilon_{i}=\log C+\alpha\log h_{i}\label{eq:scaling}\end{equation}

\end_inset

over the transformed variables 
\begin_inset Formula $X_{i}=\log h_{i}$
\end_inset

 and 
\begin_inset Formula $Y_{i}=\log\varepsilon_{i}$
\end_inset

.
 The slope of that regression line gives an estimate of 
\begin_inset Formula $\alpha.$
\end_inset

 You can use the SciPy and Matplotlib Python modules to write two functions
 that can give you precisely that estimate.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Python functions for calculating and plotting the best least-squares power
 law fit.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

import numpy
\end_layout

\begin_layout Plain Layout

import matplotlib
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

from scipy.optimize import leastsq
\end_layout

\begin_layout Plain Layout

from pylab import loglog, title, show
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def power_law_fit(X, Y):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # verify input arrays have same length
\end_layout

\begin_layout Plain Layout

    assert len(X) == len(Y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # parametric function representing power-law
\end_layout

\begin_layout Plain Layout

    power_law = lambda v,x: v[0] * x ** v[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # error function
\end_layout

\begin_layout Plain Layout

    error_fn = lambda v,x,y: (power_law(v,x) - y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # initial parameter value
\end_layout

\begin_layout Plain Layout

    v0 = (1,1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # find optimal parameters v
\end_layout

\begin_layout Plain Layout

    (v, success) = leastsq(error_fn, v0, args=(X,Y), maxfev=1000)
\end_layout

\begin_layout Plain Layout

    print 'Best fit: err =', v[0], '* h ^', v[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return (v, success)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def plot_power_law(X,Y, **kw):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    (v, success) = power_law_fit(X,Y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    x = numpy.array(X)
\end_layout

\begin_layout Plain Layout

    y = numpy.array(Y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # finally, plot points along with best-fit function.
\end_layout

\begin_layout Plain Layout

    plot_fn = kw.get('plot', loglog)
\end_layout

\begin_layout Plain Layout

    plot_fn(x, y, 'ro')
\end_layout

\begin_layout Plain Layout

    plot_fn(x, power_law(v,x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    title(r'$
\backslash
varepsilon
\backslash
 =
\backslash
 %f
\backslash
 h^{%f}$' % (v[0],v[1]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    show()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
A similar script called 
\family typewriter
power-plot.py
\family default
 is provided in the Cigma source code.
 It expects a single command line argument: a file name which contains the
 points 
\begin_inset Formula $(h_{i},\varepsilon_{i})$
\end_inset

.
 Running that script will plot the regression line associated with the points
 
\begin_inset Formula $(\log h_{i},\log\varepsilon_{i})$
\end_inset

.
\end_layout

\begin_layout Chapter
Running Cigma
\end_layout

\begin_layout Standard
Cigma is primarily designed for calculating error estimates between arbitrary
 functions.
 These functions can be defined as mathematical functions or as fields over
 finite element meshes.
 The primary operation of Cigma has the basic form
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma compare 
\emph on
FunctionA FunctionB
\end_layout

\begin_layout Standard
which executes a global comparison between two generic functions 
\family typewriter
\series bold
FunctionA
\family default
\series default
 and 
\family typewriter
\series bold
FunctionB
\family default
\series default
.
\end_layout

\begin_layout Standard
The full list of options for Cigma can be obtained by running the 
\family typewriter
cigma help
\family default
 command.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(XXX: sync output with code repo)
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma help
\begin_inset Newline newline
\end_inset

Usage: cigma <subcommand> [options] [args]
\begin_inset Newline newline
\end_inset

Type 'cigma help <subcommand>' for help on a specific subcommand.
\begin_inset Newline newline
\end_inset

Type 'cigma --version' to see the program version
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
Available subcommands:
\begin_inset Newline newline
\end_inset

   compare        Calculate global L2 error, and local differences between
 two functions
\begin_inset Newline newline
\end_inset

   list           List file contents (fields, dimensions, ...)
\begin_inset Newline newline
\end_inset

   mesh-info      Show information about specified mesh
\begin_inset Newline newline
\end_inset

   function-info  Show list of pre-defined functions
\begin_inset Newline newline
\end_inset

   element-info   Show information about available element types
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
Cigma is a tool for calculating L2-norm differences between numerical models.
\begin_inset Newline newline
\end_inset

For additional information, visit http://geodynamics.org/
\end_layout

\begin_layout Standard
In this Chapter, we give a general overview of each of these subcommands,
 explain the meaning of each of their command line options, and give hypothetica
l examples of typical usage patterns.
 We delay discussion of actual examples until the next Chapter, where we
 rely on publically available data files that can be downloaded from the
 Cigma software page at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/software/packages/cs/cigma/cigma-data-1.0.0.tar.gz
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Selecting a Dataset
\end_layout

\begin_layout Standard
In general, you will provide data to Cigma as a simple array of values.
 Because most scientific formats are capable of storing multiple datasets
 in the same file, you will need a consistent way to select a specific array
 on a given data file.
 Therefore, all option arguments to Cigma that expect a dataset can be specified
 in the form 
\family typewriter
\series bold
Filename:Location
\family default
\series default
.
 If the 
\emph on
filename
\emph default
 part unambiguously determines the target array, then the 
\emph on
location
\emph default
 part of the option argument may be omitted.
 For example, consider two HDF5 files, 
\begin_inset Quotes eld
\end_inset


\family typewriter
low_res.h5
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
high_res.h5
\family default

\begin_inset Quotes erd
\end_inset

 which each have fields 
\begin_inset Quotes eld
\end_inset


\family typewriter
density
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
pressure
\family default

\begin_inset Quotes erd
\end_inset

.
 Then the command
\end_layout

\begin_layout LyX-Code
cigma compare high_res.h5:density low_res.h5:density -o low_high.h5
\end_layout

\begin_layout Standard
will compare the density fields between the two files on the mesh defined
 in 
\family typewriter
high_res.h5
\family default
.
 
\end_layout

\begin_layout Standard
Depending on how it was configured, Cigma understands a number of different
 file formats, including HDF5 and VTK formats.
 The file format is determined by the filename extension.
\end_layout

\begin_layout Section
Comparison Options
\begin_inset CommandInset label
LatexCommand label
name "sec:Compare-Options"

\end_inset


\end_layout

\begin_layout Standard
We can exercise more control over the region of integration, and obtain
 a corresponding local error field by using the command
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma compare 
\emph on

\backslash

\begin_inset Newline newline
\end_inset

         -a FunctionA
\emph default
 
\backslash

\begin_inset Newline newline
\end_inset


\emph on
         -b FunctionB
\emph default
 
\backslash

\begin_inset Newline newline
\end_inset

         -m 
\emph on
IntegrationMesh
\emph default
 
\backslash

\begin_inset Newline newline
\end_inset

         -o
\emph on
 L2_Errors_on_IntegrationCells
\end_layout

\begin_layout Standard
This command will evaluate 
\family typewriter
\series bold
FunctionA
\family default
\series default
 and 
\family typewriter
\series bold
FunctionB
\family default
\series default
 on the quadrature points of 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
, and compute the 
\begin_inset Formula $L_{2}$
\end_inset

-norm of the difference between these two functions.
 The output file will be used to store each of the local 
\begin_inset Formula $L_{2}$
\end_inset

-differences between the two functions over the cells in the integration
 mesh.
\end_layout

\begin_layout Standard

\size footnotesize
\emph on
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(TODO: syntax for analytical function, and for fields.
 --first is optional, ditto for --second and --second-mesh)
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma compare 
\emph on
--first=FileA:DataA --first-mesh=FileA:MeshA ...
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mesh Options
\begin_inset CommandInset label
LatexCommand label
name "sec:Mesh-Options"

\end_inset


\end_layout

\begin_layout Standard
A mesh in Cigma is defined by three items: (1) the nodal Cartesian coordinates,
 (2) the connectivity (topological information describing how those nodes
 are connected to each other to form elements), and (3) an element type
 associated with the cell, e.g., triangles, quadrilaterals, tetrahedra, and
 hexahedra.
 Up to three such meshes, 
\series bold
MeshA
\series default
 (the mesh for 
\family typewriter
\series bold
FunctionA
\family default
\series default
), 
\series bold
MeshB
\series default
 (for 
\family typewriter
\series bold
FunctionB
\family default
\series default
) and the 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
, can be passed as arguments in Cigma.
 These items are determined by the following command line options, arranged
 in a tabular format for easier reference.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\size scriptsize
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size scriptsize
MeshA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size scriptsize
MeshB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size scriptsize
IntegrationMesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Item
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--first-mesh
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--second-mesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--mesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
(1,2,3)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
M1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--first-mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--second-mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
(1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
M2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--first-mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--second-mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
(2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
MC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--first-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--second-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size scriptsize
--mesh-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
(3)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
There are a number of rules determining which of these options are required.
 For any of the 
\series bold
MeshA
\series default
, 
\series bold
MeshB
\series default
, and 
\series bold
IntegrationMesh
\series default
 columns in the table above, the relationship between these options is as
 follows:
\end_layout

\begin_layout Enumerate
If option (M) is given, then options (M1) and (M2) are forbidden.
\end_layout

\begin_layout Enumerate
If option (M) is missing, then both options (M1) and (M2) must be specified.
\end_layout

\begin_layout Enumerate
Option (MC) can be deduced from option (M).
\end_layout

\begin_layout Enumerate
Option (MC) is required if options (M1) and (M2) are given.
\end_layout

\begin_layout Standard
It is important to note that currently Cigma assumes that every element
 in the mesh is defined over the same cell type.
 
\end_layout

\begin_layout Subsection
Data Layout in a Mesh File
\end_layout

\begin_layout Standard
When using an HDF5 file to store the mesh information, the 
\emph on
location
\emph default
, or internal path,
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (TODO: clarify)
\end_layout

\end_inset

 associated with option (M) must point to an HDF5 group that contains two
 arrays with the relevant mesh information.
 Those two arrays must be named 
\family typewriter
\series bold
coordinates
\family default
\series default
 and 
\family typewriter
\series bold
connectivity
\family default
\series default
.
 If the 
\emph on
location
\emph default
 is empty, as is the case when only 
\emph on
filename
\emph default
 is specified, then the HDF5 group is assumed to be the root group 
\family typewriter
(/)
\family default
 of the hierarchy.
 Lastly, the option (MC) can be omitted if the HDF5 group has an attribute
 called 
\family typewriter
\series bold
\emph on
CellType
\family default
\series default
\emph default
 with the appropriate value.
 A typical hierarchy that specifies a mesh would look like this:
\end_layout

\begin_layout LyX-Code
File mesh.h5
\end_layout

\begin_layout LyX-Code

\emph on
 
\emph default
`Group
\emph on
 
\emph default
/mesh
\end_layout

\begin_layout LyX-Code
  |-- Attribute 
\series bold
CellType
\end_layout

\begin_layout LyX-Code
  |-- Array 
\series bold
coordinates
\end_layout

\begin_layout LyX-Code
  `-- Array 
\series bold
connectivity
\end_layout

\begin_layout Standard
One may specify options (M1) and (M2) separately by pointing directly to
 the arrays corresponding to the coordinates and connectivity information.
 The node ordering on the connectivity dataset is described in Appendix
 A.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(TODO: an example when coordinates/connectivity/celltype are in different
 datagroup.)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, using a VTK file is very convenient.
 In this case, no 
\emph on
location
\emph default
 needs to be specified since all the appropriate information are always
 in the VTK file.
 The value of the option (MC) is determined from the first entry in the
 
\family typewriter
CELL_TYPES
\family default
 dataset, since we are limiting ourselves to element blocks consisting of
 a single cell type.
 
\end_layout

\begin_layout Standard
Another convenient way to prepare a mesh file for use with Cigma is to use
 the ExodusII format created by the CUBIT mesh generation toolkit.
 In this case, the mesh can be stored on disk using the NetCDF format.
 It suffices to give the 
\emph on
filename
\emph default
, without the 
\emph on
location
\emph default
 part, to option (M).
 The appropriate mesh information will be read from the file.
 Only the first element block in the ExodusII file is used.
 The value of the (MC) option is determined from the NetCDF string attribute
 
\family typewriter
elem_type
\family default
 that is attached to the NetCDF integer variable called 
\family typewriter
connect1
\family default
.
\end_layout

\begin_layout Standard
Lastly, it is also possible to use a simple text file, in which case all
 three options (M1), (M2), and (MC) are required.
\end_layout

\begin_layout Subsection
Integration Mesh
\end_layout

\begin_layout Standard
An integration mesh can be specified by the command line options, subject
 to the following rules:
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
 is specified, then it is used.
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
 is missing, then 
\family typewriter
\series bold
MeshA
\family default
\series default
 is used as 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
.
\end_layout

\begin_layout Enumerate
If only 
\family typewriter
\series bold
MeshB
\family default
\series default
 is given, then it is used as 
\family typewriter
\series bold
IntegrationMesh
\family default
\series default
.
\end_layout

\begin_layout Standard
Deciding if a given mesh is adequate for accurately capturing the error
 in the comparison will clearly depend on the functions being compared.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(TODO: need enough resolution for integrationmesh) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One strategy to ensure an adequate mesh would be to take the discretization
 cells on which the error metric exceeds a certain threshold, mark those
 cells for refinement, and recalculate the errors over the new discretization,
 repeating the process if necessary.
 This strategy could be implemented on top of Cigma as a series of post-processi
ng steps by writing a suitable program or script that repeats this refinement
 process until the variations in the global error metric are small enough.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Both of the TetGen and CUBIT mesh generators can be used for this purpose.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A second strategy would be to increase the order of the quadrature rule
 that we associate with the cells in the integration mesh.
 This approach has the advantage that we can increase the accuracy of the
 
\begin_inset Formula $L_{2}$
\end_inset

-norm without performing pre- and post-processing on a sequence of integration
 meshes.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IntegrationRule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule-points
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule-weights
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
A number of common quadrature rules, including high-order quadratures, for
 different cell types are available by default.
 They are stored in file 
\family typewriter
integration-rules.h5
\family default
, which was generated using the Jacobi quadrature rules available in the
 FIAT (finite element automatic tabulator) Python module.
 Using these higher-order quadrature rules should allow you to increase
 the accuracy of the 
\begin_inset Formula $L_{2}$
\end_inset

-norm integral without having to adaptively refine the integration meshes.
\end_layout

\begin_layout Standard
The default integration rule used on each cell type can be obtained by running
 the 
\family typewriter
cigma element-info
\family default
 command, as shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Working-with-Elements"

\end_inset

.
\end_layout

\begin_layout Section
Function Options
\end_layout

\begin_layout Standard
Cigma will accept two kinds of function arguments: (1) an analytic function
 chosen from a pre-defined list, or (2) a finite element field.
 Of these two, only the second kind is associated with a specific mesh.
 Therefore, when comparing two analytic functions, an integration mesh must
 (XXX).
\end_layout

\begin_layout Subsection
Analytic Functions
\end_layout

\begin_layout Standard
Sometimes you will be able to express a function in terms of a general formula
 or algorithm, in which case you would like to be able to refer to such
 a function by using a simple name when specifying either of the 
\family typewriter
\series bold
FunctionA
\family default
\series default
 or 
\family typewriter
\series bold
FunctionB
\family default
\series default
 arguments.
 Extending Cigma by defining your own functions is ideal (XXX) for analytic
 functions for benchmarking your own code.
 
\end_layout

\begin_layout Standard
Two such examples can be found in the Cigma source code.
 A simple analytic function is available in the 
\family typewriter
fn_inclusion.h
\family default
 and 
\family typewriter
fn_inclusion.cpp
\family default
 source files (used in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Circular-Inclusion-Benchmark"

\end_inset

), while a more complex function which calls external procedures is available
 in 
\family typewriter
fn_disloc3d.h
\family default
 and 
\family typewriter
fn_disloc3d.cpp
\family default
.
 If you wish to define your own analytic functions, it might be instructive
 to use either of these two examples as a template.
\end_layout

\begin_layout Subsection
Finite Element Fields
\end_layout

\begin_layout Standard
A finite element description of a function is associated with three items
 of information: (1) a discretization (nodes and connectivity), (2) a finite
 set of local basis functions (cell type) defined on the discretization,
 and finally (3) a global list of coefficients defined on the nodes that
 yield the closest approximation to the function.
 How these items are specified depends on the underlying file format used
 to store the finite element description to our function.
 Items (1) and (2) are typically deduced from the appropriate mesh options
 discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Mesh-Options"

\end_inset

, while item (3) is determined from the dataset given to either of the 
\family typewriter
--first
\family default
 or 
\family typewriter
--second
\family default
 command line options.
\end_layout

\begin_layout Standard
If the dataset is stored in an HDF5 file, item (3) would be typically specified
 as a single array containing the shape function coefficients.
 You can optionally attach an attribute called 
\family typewriter
\series bold
MeshLocation
\family default
\series default
 to that dataset, which points to the mesh datagroup.
\end_layout

\begin_layout LyX-Code
File
\emph on
 
\emph default

\begin_inset Quotes eld
\end_inset

model.h5
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\emph on
 
\emph default
 Group
\emph on
 
\series bold
\emph default
fields
\end_layout

\begin_layout LyX-Code
  |-- Group 
\series bold
temperature
\end_layout

\begin_layout LyX-Code
  |   |-- Array 
\series bold
step000
\end_layout

\begin_layout LyX-Code
  |   |   `-- Attribute 
\series bold
MeshLocation
\end_layout

\begin_layout LyX-Code
  |   |-- Array 
\series bold
step001
\end_layout

\begin_layout LyX-Code
  |   |   `-- Attribute 
\series bold
MeshLocation
\end_layout

\begin_layout LyX-Code
  |   `-- ...
\end_layout

\begin_layout LyX-Code
  `-- Group 
\series bold
displacements
\end_layout

\begin_layout LyX-Code
      |-- ...
\end_layout

\begin_layout LyX-Code
      `-- ...
\end_layout

\begin_layout Standard
Note that in this example, we have grouped all fields by variable name first
 (e.g., temperature and displacements) and then by time step, but we could
 have easily grouped everything by time step first and then by variable
 name.
 Cigma will only operate on the full path to a dataset, leaving you the
 freedom to organize your data as you see fit.
\end_layout

\begin_layout Standard
If the dataset is stored in a VTK file, the only restrictions are that you
 can only compare against Point Data arrays, and one cell type per file.
 Otherwise, you may use any of the formats supported by the VTK library
 (structured, rectilinear, etc.) to define your field.
\end_layout

\begin_layout Subsection
Spatial Database Options
\end_layout

\begin_layout Standard
Recall from Chapter 3 that computing the local error metric involves approximati
ng a local error integral by a finite weighed sum over a set of quadrature
 points.
 Because we allow arbitrary meshes for the integration procedure, that means
 that in general we must be able to evaluate our functions wherever those
 quadrature points may lie.
 This implies that we must be able to evaluate the given functions at arbitrary
 points.
 This step is typically inefficient even for a moderate-size finite element
 mesh, since a sequential scan over a mesh with 
\begin_inset Formula $n$
\end_inset

 elements would take 
\begin_inset Formula $O(n)$
\end_inset

 time per quadrature point evaluation.
 To make this process efficient in general, we can build a spatial-index
 database of the geometric locations of every element in the mesh.
 Using a tree-based partitioning of the element locations, we can ideally
 reduce the search time to 
\begin_inset Formula $O(\log n)$
\end_inset

 per quadrature point evaluation.
 
\end_layout

\begin_layout Standard
Cigma uses a nearest-neighbor search on a kd-tree structure to find the
 appropriate cell that contains a given quadrature point.
 This means that for a given point, a fixed number of nearest neighbors
 are checked before proceeding with a sequential scan over all elements.
 If you find a particular comparison is taking too long, it may help to
 increase the number of nearest elements that are checked, which can be
 done by passing a positive integer to any of the command line options 
\family typewriter
--first-mesh-nnk
\family default
 and 
\family typewriter
--second-mesh-nnk
\family default
.
\end_layout

\begin_layout Standard
For meshes with more structure, it would be possible to define an appropriate
 
\family typewriter
cigma::Locator
\family default
 subclass to provide a search time of 
\begin_inset Formula $O(1)$
\end_inset

 per quadrature point evaluation, but this is not currently implemented
 in Cigma.
 
\end_layout

\begin_layout Section
Other Options
\end_layout

\begin_layout Standard
There are a few other notable options that enable us to monitor the timing
 statistics on the progress of the calculation, as well as debugging information
 that may prove useful when encountering an unexpected exception.
\end_layout

\begin_layout Standard
In order to monitor the progress of the integration, simply add the 
\family typewriter
--verbose
\family default
 (or 
\family typewriter
-v
\family default
) flag to the command options,
\end_layout

\begin_layout LyX-Code
$ cigma compare FunctionA
\series bold
 
\series default
FunctionB
\series bold
 --verbose
\end_layout

\begin_layout Standard
By default, the timer will report its progress every 100 integration cells,
 but you can change that default by using the option 
\family typewriter
--timer-frequency
\family default
 (or 
\family typewriter
-t
\family default
),
\end_layout

\begin_layout LyX-Code
$ cigma compare FunctionA
\series bold
 
\series default
FunctionB
\series bold
 --verbose --timer-frequency=1000
\end_layout

\begin_layout Standard
Debugging information can be displayed using the 
\family typewriter
--debug
\family default
 (or 
\family typewriter
-D
\family default
) flag, which will output an internal trace of which functions have been
 called and with what arguments.
\end_layout

\begin_layout LyX-Code
$ cigma compare FunctionA
\series bold
 
\series default
FunctionB 
\series bold
--debug
\end_layout

\begin_layout Standard
On the other hand, suppressing all output can be accomplished with the 
\family typewriter
--quiet
\family default
 flag.
 This flag is probably most useful when used together with the option 
\family typewriter
--global-threshold
\family default
 (or 
\family typewriter
-g
\family default
),
\end_layout

\begin_layout LyX-Code
$ cigma compare FunctionA
\series bold
 
\series default
FunctionB --quiet --global-threshold=0.001
\end_layout

\begin_layout Standard
In this case, the exit code will indicate failure (i.e., return a non-zero
 value) whenever the 
\begin_inset Formula $L_{2}$
\end_inset

-norm is grearter than the specified threshold condition.
 This allows you to set up automated regression scripts that can constantly
 compare output from your numerical codes against a series of known benchmark
 solutions.
\end_layout

\begin_layout Section
Visualizing the Local Errors
\end_layout

\begin_layout Standard
The command 
\family typewriter
cigma compare
\family default
 will always output the local 
\begin_inset Formula $L_{2}$
\end_inset

-errors in the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 form described in Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cell-residual"

\end_inset

.
 However, for visualization purposes, it's more convenient to normalize
 those integrated errors 
\begin_inset Formula $\varepsilon_{i}$
\end_inset

 by the corresponding integration-cell volumes 
\begin_inset Formula $v_{i}$
\end_inset

, so that errors accumulated over smaller cells have more visual influence
 than errors of the same magnitude accumulated over larger cells.
 Additionally, it may also be more useful to output the logarithm of the
 normalized errors instead.
 Using a logarithmic scale will accentuate the contrast between the orders
 of magnitude when visualizing the normalized 
\begin_inset Formula $L_{2}$
\end_inset

-error field.
\end_layout

\begin_layout Standard
For these reasons, we include in Cigma a post-processing utility called
 
\family typewriter
visualize-errors
\family default
 that can take our error fields stored in HDF5 format and create a simple
 legacy VTK file, which can then be conveniently visualized using many other
 visualization packages.
 The utility 
\family typewriter
visualize-errors
\family default
 can be used as follows,
\end_layout

\begin_layout LyX-Code
$ visualize-errors [--use-logarithmic-scale] 
\backslash

\end_layout

\begin_layout LyX-Code
      -m MeshFile.h5:/meshpath               
\backslash

\end_layout

\begin_layout LyX-Code
      -i InputErrors.h5:/errorpath           
\backslash

\end_layout

\begin_layout LyX-Code
      -o OutputErrors.vtk:NormalizedErrors
\end_layout

\begin_layout Standard
Specifically, this command will take each of the local errors 
\begin_inset Formula $\varepsilon_{i}$
\end_inset

 from the HDF5 file 
\family typewriter
InputErrors.h5
\family default
, normalize them by the factor 
\begin_inset Formula $\sqrt{v_{i}}$
\end_inset

, where 
\begin_inset Formula $v_{i}$
\end_inset

 is the corresponding volume of the 
\begin_inset Formula $i$
\end_inset

-th cell taken from 
\family typewriter
MeshFile.h5
\family default
, and write the result to a VTK file called 
\family typewriter
OutputErrors.vtk
\family default
 under an array called 
\family typewriter
NormalizedErrors
\family default
.
 One may also specify the flag 
\family typewriter
--use-logarithmic-scale
\family default
, in which case the above command will take the logarithm (in base 10) before
 writing the final results to the VTK file.
\end_layout

\begin_layout Section
Verifying the Results
\end_layout

\begin_layout Standard
The rest of the Cigma commands are there to help you query your model data
 files, allowing you to determine whether the input files are being interpreted
 properly.
 A common problem in specifying a finite element mesh is using the wrong
 node numbering for a particular Cigma element, in which case you will probably
 encounter cells with negative or zero volumes, and incorrect results for
 the inverse reference map 
\begin_inset Formula $\vec{x}_{e}^{-1}(\vec{x})$
\end_inset

.
 Also, if the degrees of freedom are specified using a different node ordering
 than the mesh, the interpolation will yield different results than expected.
 Querying your model at a number of pre-selected points will probably curtail
 most of these mistakes when preparing your input files.
\end_layout

\begin_layout Subsection
Working with a Mesh
\end_layout

\begin_layout Standard
Using the command 
\family typewriter
cigma mesh-info
\family default
, you can examine your mesh files and extract basic information such as
 the number of nodes and cells, the total volume, bounding box, and the
 maximum cell diameter of your mesh.
\end_layout

\begin_layout LyX-Code
$ cigma mesh-info MESH
\end_layout

\begin_layout Standard
You can also extract connectivity information for a specific cell in your
 mesh, which will help you find out whether the elements that your finite
 element model use have the same node ordering as the elements in Cigma,
\end_layout

\begin_layout LyX-Code
$ cigma mesh-info MESH --cell-id=N
\end_layout

\begin_layout Standard
Lastly, you can also query an arbitrary point within the mesh,
\end_layout

\begin_layout LyX-Code
$ cigma mesh-info MESH --query-point=
\begin_inset Quotes erd
\end_inset

[x,y,z]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This will return the information of the cell that contains the query point,
 which is useful to verify that the underlying spatial index that maps points
 to cells is working properly.
\end_layout

\begin_layout Subsection
Working with Analytic Functions
\end_layout

\begin_layout Standard
Finding information on given function can be done with the 
\family typewriter
cigma function-info
\family default
 command.
 Using it without arguments will return the list of analytic functions that
 have been compiled into Cigma.
 Two special scalar functions, 
\end_layout

\begin_layout LyX-Code
$ cigma function-info
\begin_inset Newline newline
\end_inset

one
\begin_inset Newline newline
\end_inset

zero
\begin_inset Newline newline
\end_inset

...
\end_layout

\begin_layout Standard
You can also query any function accepted by the 
\family typewriter
cigma compare
\family default
 command, not just built-in analytic functions, at any arbitrary point in
 its function domain,
\end_layout

\begin_layout LyX-Code
$ cigma function-info FUNCTION --query-point=
\begin_inset Quotes erd
\end_inset

[x,y,z]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This will allow you to verify whether the function is reporting the correct
 value at the expected point.
 You can use this to check that the element interpolations are done correctly,
 and whether a newly defined analytic function returns the appropriate values
 on a selection of points.
\end_layout

\begin_layout Subsection
Working with Elements
\begin_inset CommandInset label
LatexCommand label
name "sub:Working-with-Elements"

\end_inset


\end_layout

\begin_layout Standard
On a more basic level, you can also verify that the basis functions for
 your reference element work as expected, especially if you decide to extend
 Cigma by adding your own element types.
 Calling the 
\family typewriter
cigma element-info
\family default
 command without arguments will generate the list of registered elements.
 Note that the names of the element types listed here correspond to the
 acceptable values that you can give to the (MC) argument discussed in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Mesh-Options"

\end_inset

.
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma element-info
\begin_inset Newline newline
\end_inset

List of elements available for use in a Field:
\begin_inset Newline newline
\end_inset

   tet4, hex8
\begin_inset Newline newline
\end_inset

   tri3, quad4
\end_layout

\begin_layout Standard
For example, querying the hex8 element would result in the following information
 being displayed
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma element-info hex8
\begin_inset Newline newline
\end_inset

Information on cell 'hex8'
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
Reference-Cell Nodes:
\end_layout

\begin_layout LyX-Code

\size footnotesize
     0  -1.000000 -1.000000 -1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     1  +1.000000 -1.000000 -1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     2  +1.000000 +1.000000 -1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     3  -1.000000 +1.000000 -1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     4  -1.000000 -1.000000 +1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     5  +1.000000 -1.000000 +1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     6  +1.000000 +1.000000 +1.000000
\end_layout

\begin_layout LyX-Code

\size footnotesize
     7  -1.000000 +1.000000 +1.000000
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
Shape functions:
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[0] = 0.125 * (1.0 - u) * (1.0 - v) * (1.0 - w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[1] = 0.125 * (1.0 + u) * (1.0 - v) * (1.0 - w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[2] = 0.125 * (1.0 + u) * (1.0 + v) * (1.0 - w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[3] = 0.125 * (1.0 - u) * (1.0 + v) * (1.0 - w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[4] = 0.125 * (1.0 - u) * (1.0 - v) * (1.0 + w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[5] = 0.125 * (1.0 + u) * (1.0 - v) * (1.0 + w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[6] = 0.125 * (1.0 + u) * (1.0 + v) * (1.0 + w)
\end_layout

\begin_layout LyX-Code

\size footnotesize
   N[7] = 0.125 * (1.0 - u) * (1.0 + v) * (1.0 + w)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
Default integration rule (weights & points):
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   -0.577350 -0.577350 -0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   +0.577350 -0.577350 -0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   +0.577350 +0.577350 -0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   -0.577350 +0.577350 -0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   -0.577350 -0.577350 +0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   +0.577350 -0.577350 +0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   +0.577350 +0.577350 +0.577350
\end_layout

\begin_layout LyX-Code

\size footnotesize
    1.000000   -0.577350 +0.577350 +0.577350
\size default
 
\end_layout

\begin_layout Standard
Querying the shape function values is possible by using the previously discussed
 command 
\family typewriter
cigma function-info
\family default
 and an appropriately defined mesh containing a single element.
 These reference meshes are provided in the top level data file 
\family typewriter
reference-cells.h5
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For example, querying 
\begin_inset Formula $N_{0}$
\end_inset

 for tet4 reference cell would be accomplished with
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma function-info reference-cells.h5:/tet4/dofs/N0 --query-point 0,0,0
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma function-info reference-cells.h5:/tet4/dofs/N0 --query-point 1,0,0
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma function-info reference-cells.h5:/tet4/dofs/N0 --query-point 0,1,0
\end_layout

\begin_layout LyX-Code

\size footnotesize
$ cigma function-info reference-cells.h5:/tet4/dofs/N0 --query-point 0,0,1
\end_layout

\begin_layout Plain Layout
which serves as a quick check that 
\begin_inset Formula $N_{0}$
\end_inset

 evaluates to 1 at one vertex, and to 0 at the other vertices.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Examples
\end_layout

\begin_layout Standard
In this chapter, we show how to use Cigma to run specific comparisons on
 included datasets, estimate the order of convergence of the numerical methods
 used in obtaining those solutions, and visualize the resulting error fields.
\end_layout

\begin_layout Section
Poisson Problem
\end_layout

\begin_layout Standard
Cigma can compare two functions and return the 
\begin_inset Formula $L_{2}$
\end_inset

-norm difference between those two functions.
 For a given numerical problem, if you compute the solutions over a range
 of resolutions, you can use this global measure to quantify the rate of
 convergence of your numerical method.
 To demonstrate how this works, we will use the two Poisson problems: 
\end_layout

\begin_layout Standard
(1) 
\begin_inset Formula $\nabla^{2}\phi(x,y)=4x^{4}+4y^{4}$
\end_inset

 inside 
\begin_inset Formula $\Omega=[-1,1]^{2}$
\end_inset

, subject to the Dirichlet boundary condition 
\begin_inset Formula $\phi(x_{0},y_{0})=x_{0}^{2}+y_{0}^{2}$
\end_inset

 on the boundary 
\begin_inset Formula $\partial\Omega$
\end_inset

, and 
\end_layout

\begin_layout Standard
(2) 
\begin_inset Formula $\nabla^{2}\phi(x,y,z)=4x^{4}+4y^{4}+4z^{4}$
\end_inset

 on 
\begin_inset Formula $\Omega=[-1,1]^{3}$
\end_inset

 subject to 
\begin_inset Formula $\phi(x_{0},y_{0},z_{0})=x_{0}^{2}+y_{0}^{2}+z_{0}^{2}$
\end_inset

 on the boundary 
\begin_inset Formula $\partial\Omega$
\end_inset

.
 
\end_layout

\begin_layout Standard
These differential equations can be easily solved numerically by using a
 finite element software library called Deal.II, which supports Lagrange
 finite elements of any order in either 2 or 3 dimensions.
 In fact, the two equations we have described are already solved in Step
 4 in the list of the Deal.II tutorial programs in 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

dealii.org/developer/doxygen/tutorial/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In the 
\family typewriter
examples/
\family default
 subdirectory, we include a version of the Step 4 tutorial program that
 has been slightly modified to suit our purposes in this section.
 First, we change the output format to use VTK files, in order to make it
 very convenient for us to provide our input datasets to Cigma.
 Next, we solve the 2D problem over meshes of resolution 
\begin_inset Formula $64\times64$
\end_inset

, 
\begin_inset Formula $32\times32$
\end_inset

, 
\begin_inset Formula $16\times16$
\end_inset

, and 
\begin_inset Formula $8\times8$
\end_inset

 by using linear quadrilateral elements.
 The solution is saved in file 
\family typewriter
phi_64x64x64.vtk
\family default
 for the highest resolution, for example.
 In a similar fashion, we solve our 3D Poisson problem on meshes of resolution
 
\begin_inset Formula $64\times64\times64$
\end_inset

, 
\begin_inset Formula $32\times32\times32$
\end_inset

, 
\begin_inset Formula $16\times16\times16$
\end_inset

, and 
\begin_inset Formula $8\times8\times8$
\end_inset

, that use linear hexahedral elements.
 Note that in either case, we don't really know the exact solution to either
 problem, so we use the highest resolution available as the reference point
 for our comparisons.
 The following bash shell command can take care of all the comparisons
\end_layout

\begin_layout LyX-Code
$ for r in 32 16 8; do
\end_layout

\begin_layout LyX-Code
    cigma compare phi_64x64.vtk     phi_${r}x${r}.vtk
\end_layout

\begin_layout LyX-Code
    cigma compare phi_64x64x64.vtk  phi_${r}x${r}x${r}.vtk
\end_layout

\begin_layout LyX-Code
  done
\end_layout

\begin_layout Standard
When we run the above code on the command line, or script, Cigma will generate
 a summary of each comparison, including the 
\begin_inset Formula $L_{2}$
\end_inset

 norm of the difference between the two functions, and other basic mesh
 information such as its volume 
\begin_inset Formula $V$
\end_inset

 and maximum cell diagonal 
\begin_inset Formula $h$
\end_inset

.
 We summarize that information in the following tables:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="7">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $||\phi_{n}-\phi_{64\times64}||_{L_{2}}/\sqrt{V}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $||\phi_{n}-\phi_{64\times64\times64}||_{L_{2}}/\sqrt{V}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8\times8$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.35355
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.012312
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8\times8\times8$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.43301
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.019205
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $16\times16$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.17677
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.003157
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $16\times16\times16$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.21650
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004889
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $32\times32$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.08838
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000689
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $32\times32\times32$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.10825
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001075
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
It should become apparent from these results that the global error metric
 
\begin_inset Formula $\varepsilon$
\end_inset

 does indeed decrease with increasing resolution at the expected rate.
 To verify the exact order of convergence, you can use regression analysis
 to fit a power law through the above points, and obtain the following plots:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm1/alpha.png
	lyxscale 60
	scale 30

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Convergence of 
\begin_inset Formula $L_{2}$
\end_inset

 Global Error for Poisson problems in 2D and 3D.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Based on the slope of the lines in the above log-log plots, we have indeed
 verified that the global errors behave as 
\begin_inset Formula $\varepsilon=Ch^{2}$
\end_inset

, as expected from a method that uses linear elements.
 
\end_layout

\begin_layout Section
Mantle Convection
\end_layout

\begin_layout Standard
In addition to reporting a global error metric, Cigma can also output local
 errors between two fields, averaged over each of the integration cells
 used in the calculation of the 
\begin_inset Formula $L_{2}$
\end_inset

 norm (or error).
 You can use this scalar error field to ascertain a number of physical insights
 by correlating the spatial regions that contribute the most to the global
 error.
\end_layout

\begin_layout Standard
For our next example, we use CitcomCU, a CIG code for mantle convection,
 to solve a thermal convection problem inside a three-dimensional domain
 under base heating, stress-free boundary conditions, constant viscosity,
 and using a Rayleigh number of 
\begin_inset Formula $10^{5}$
\end_inset

 in the domain 
\begin_inset Formula $\Omega=[0,1]^{3}$
\end_inset

.
 Under these conditions, we expect the solution to this problem to eventually
 converge to a steady state consisting of a single convection cell.
 We then use Cigma to compare those steady state solutions in order to recover
 the order of convergence of the CitcomCU numerical code and to examine
 how the error behaves on a representative slice of the original domain.
 
\end_layout

\begin_layout Standard
Again, as in the previous section, we solve the same problem over four different
 resolutions, and then use the highest resolution dataset as the reference
 point for all the subsequent comparisons.
 The four cases we will use for this example use 
\begin_inset Formula $64\times64\times64$
\end_inset

, 
\begin_inset Formula $32\times32\times32$
\end_inset

, 
\begin_inset Formula $16\times16\times16$
\end_inset

, and 
\begin_inset Formula $8\times8\times8$
\end_inset

 elements.
 In the following figure, we display the temperature and velocity fields
 on the 
\begin_inset Formula $y=0.99$
\end_inset

 plane, near one of the faces of the domain.
 We can distinctly identify an upwelling and downwelling cycle, as well
 as sharp gradients in the temperature field.
 The variations in the velocity field are smoother throughout the slice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm2/out/fig_fields_64_20000_y099.png
	lyxscale 40
	scale 29

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Slice of the steady state temperature and velocity fields for our thermal
 convection problem, on the 
\begin_inset Formula $y=0.99$
\end_inset

 plane.
 In the temperature plot (a), we show ten equally spaced contour values.
 In the velocity plot (b), the vectors represent the 
\begin_inset Formula $xz$
\end_inset

-plane components of the velocity, while the colors represent the velocity
 magnitude.
 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Once we obtain the solutions for our four resolutions over 20000 solution
 steps, we process the ASCII output data from CitcomCU into a number of
 rectilinear grids in VTK format (*.vtr files), and a subsequent *.pvtr file
 for each solution step.
\end_layout

\begin_layout Standard
As a preliminary step, we also need to ensure that each of our cases do
 indeed reach a steady state.
 We can verify this fact numerically by using Cigma to compare the same
 field at two different times, and checking that the 
\begin_inset Formula $L_{2}$
\end_inset

-error is negligible.
 However, for this problem, we can also visually verify that the solution
 has reached steady state by checking that the oscillations in the values
 of the average heat flux on the top surface have dampened out, as shown
 by Figure 5.3,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm2/heatflux.png
	lyxscale 80
	scale 40

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Time variation of average heat flux over top surface.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Our first comparison of two steady states is simple enough.
 Although it is not critical for this example since we have already converged,
 in general time-dependent problems you must ensure you are comparing solutions
 at the same absolute time.
 Thus, even though it appears that the following command is comparing two
 different solution steps, they actually correspond to roughly the same
 physical time.
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
    -a case64.20000.pvtr:temperature 
\backslash

\end_layout

\begin_layout LyX-Code
    -b case32.9900.pvtr:temperature  
\backslash

\end_layout

\begin_layout LyX-Code
    -o steady-state.h5:/error_temperature_64_32
\end_layout

\begin_layout Standard
Since we did not specify an integration mesh through the 
\family typewriter
-m
\family default
 option, Cigma will take the mesh from the first field and use it for the
 integration of the 
\begin_inset Formula $L_{2}$
\end_inset

 error.
 We have, however, used the 
\family typewriter
-o
\family default
 option to specify an output file.
 This will create the HDF5 file 
\family typewriter
steady-state.h5
\family default
 after the comparison is complete, and store the results of that comparison
 into an array called 
\family typewriter
error_temperature_64_32
\family default
 under the HDF5 
\family typewriter
/
\family default
 root group.
 You may also refer to the same HDF5 file in subsequent runs of Cigma.
 The target dataset will be appended to the file if it doesn't exist, and
 overwritten if it does.
 The commands for other two comparisons are,
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
    -a case64.20000.pvtr:temperature 
\backslash

\end_layout

\begin_layout LyX-Code
    -b case16.4700.pvtr:temperature 
\backslash

\end_layout

\begin_layout LyX-Code
    -o steady-state.h5:/error_temperature_64_16
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
    -a case64.20000.pvtr:temperature 
\backslash

\end_layout

\begin_layout LyX-Code
    -b case8.2100.pvtr:temperature 
\backslash

\end_layout

\begin_layout LyX-Code
    -o steady-state.h5:/error_temperature_64_8
\end_layout

\begin_layout Standard
Comparisons involving the velocity can be obtained in a similar manner.
 Note that even though we are comparing vectors here, the resulting errors
 will be scalars, since Cigma is integrating the scalar function 
\begin_inset Formula $||\vec{v}_{a}(\vec{x})-\vec{v}_{b}(\vec{x})||^{2}$
\end_inset

.
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
     -a case64.20000.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -b case32.9900.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -o steady-state.h5:/error_velocity_64_32
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
     -a case64.20000.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -b case16.4700.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -o steady-state.h5:/error_velocity_64_16
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
     -a case64.20000.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -b case8.2100.pvtr:velocity 
\backslash

\end_layout

\begin_layout LyX-Code
     -o steady-state.h5:/error_velocity_64_8
\end_layout

\begin_layout Standard
At this point, you have obtained the local 
\begin_inset Formula $L_{2}$
\end_inset

-errors for each of the above comparisons, and have stored them in arrays
 inside the file 
\family typewriter
steady-state.h5
\family default
.
 In order to visualize these errors, you will need to reattach the original
 mesh information by using a post-processing utility program called 
\family typewriter
visualize-errors
\family default
.
 We can accomplish this for our six comparisons, by using the following
 bash comand line,
\end_layout

\begin_layout LyX-Code
$ for variable in temperature velocity; do
\end_layout

\begin_layout LyX-Code
    for b in 32 16 8; do
\end_layout

\begin_layout LyX-Code
      visualize-errors 
\backslash

\end_layout

\begin_layout LyX-Code
        --use-logarithmic-scale 
\backslash

\end_layout

\begin_layout LyX-Code
        -m case64.20000.vtr 
\backslash

\end_layout

\begin_layout LyX-Code
        -i steady-state.h5:/error_${variable}_64_${b} 
\backslash

\end_layout

\begin_layout LyX-Code
        -o log_error_temperature_64_${b}.vtk:log_error_${variable}
\end_layout

\begin_layout LyX-Code
    done
\end_layout

\begin_layout LyX-Code
  done
\end_layout

\begin_layout Standard
The first two options we give our post-processing program are important.
 The first option eliminates the volume scale factor in the definition of
 the local 
\begin_inset Formula $L_{2}$
\end_inset

 error (larger cells contribute more than smaller cells, which would be
 more obvious if the error were constant).
 The second option tells the post-processing program to use a logarithmic
 scale for writing those locally averaged errors.
 Using a log-10 scale makes it much easier to spot the spatial range of
 variation in our error fields.
\end_layout

\begin_layout Standard
In Figure 5.4, we show two plots representing the errors in the temperature
 field on the 
\begin_inset Formula $y=0.99$
\end_inset

 plane for the two 
\begin_inset Formula $16\times16\times16$
\end_inset

 and 
\begin_inset Formula $32\times32\times32$
\end_inset

 resolutions, relative to the 
\begin_inset Formula $64\times64\times64$
\end_inset

 temperature solution.
 Examining this plot and Figure 5.2a reveals that the largest errors are
 concentrated in areas where the temperature gradient is also large, near
 the boundary layers created by activity from the upwelling and downwelling.
 Similarly, the region where the errors are smallest corresponds to a region
 where both the temperature gradients and velocity magnitude are at their
 lowest.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm2/out/fig_log_error_temperature_64_16_64_32_y099.png
	lyxscale 40
	scale 28

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Temperature differences on 
\begin_inset Formula $y=0.99$
\end_inset

 plane, as compared against case with 
\begin_inset Formula $64\times64\times64$
\end_inset

 elements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Likewise, in Figure 5.5 we show two plots representing the magnitude of the
 velocity field on the same plane.
 This time, the distribution of the largest errors are spread out more evenly
 over the domain.
 In this case, the largest errors in the velocity field also correspond
 to regions where the magnitude of the velocity field is the largest.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm2/out/fig_log_error_velocity_64_16_64_32_y099.png
	lyxscale 40
	scale 28

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Velocity differences on 
\begin_inset Formula $y=0.99$
\end_inset

 plane, as compared against case with 
\begin_inset Formula $64\times64\times64$
\end_inset

 elements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Circular Inclusion Benchmark
\begin_inset CommandInset label
LatexCommand label
name "sec:Circular-Inclusion-Benchmark"

\end_inset


\end_layout

\begin_layout Standard
In some cases, you will be able to obtain an exact solution to your differential
 equations.
 In these cases, you can extend Cigma by implementing your function directly
 in C++, and registering a convenient name under which to call it.
 In this section, we'll show you exactly how to accomplish this by considering
 a two-dimensional problem for which an exact analytical solution is known.
 In a 2003 paper 
\begin_inset CommandInset citation
LatexCommand cite
key "Schmid Podladchikov 2003"

\end_inset

, Schmid and Podladchikov derived an analytic solution for the pressure
 and velocity fields of a circular inclusion under simple shear, depicted
 in Figure 5.6.
 The viscosity parameters introduced are 
\begin_inset Formula $\mu_{m}$
\end_inset

 for the viscosity of the matrix, and 
\begin_inset Formula $\mu_{i}$
\end_inset

 for the viscosity of the inclusion.
 The kinematic boundary conditions are given generally in terms of the simple
 shear strain rate 
\begin_inset Formula $\dot{\epsilon}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/inclusion_setup.eps
	scale 60
	rotateOrigin center

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Schematic for the circular inclusion benchmark.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particular, we place the inclusion of radius 
\begin_inset Formula $r_{i}=0.1$
\end_inset

 at the origin, and exploit the symmetry in this problem by only solving
 the field on the top right quarter of the domain.
\end_layout

\begin_layout Standard
From 
\begin_inset CommandInset citation
LatexCommand cite
key "Schmid Podladchikov 2003"

\end_inset

, we end up with the following analytic formula for the pressure field under
 the case of simple shear, 
\begin_inset Formula \begin{equation}
p=\begin{cases}
4\dot{\epsilon}\frac{\mu_{m}(\mu_{i}-\mu_{m})}{\mu_{i}+\mu_{m}}\left(\frac{r_{i}^{2}}{r^{2}}\right)\cos(2\theta) & r>r_{i}\\
0 & r<r_{i}\end{cases}\label{eq:circular-inclusion}\end{equation}

\end_inset

where we use 
\begin_inset Formula $\mu_{i}=2$
\end_inset

 for the viscosity of the inclusion, 
\begin_inset Formula $\mu_{m}=1$
\end_inset

 for the viscosity of the background media, and 
\begin_inset Formula $\dot{\epsilon}=1$
\end_inset

 for the magnitude of the shear.
 In Cigma, you can refer to this specific analytic solution by the somewhat
 verbose name 
\family typewriter
bm.circular_inclusion.pressure
\family default
, whose definition is summarized in Listing 5.1.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Definition of the 
\family typewriter
bm.circular_inclusion.pressure
\family default
 analytic function.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

#include 
\begin_inset Quotes eld
\end_inset

Function.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace benchmark {
\end_layout

\begin_layout Plain Layout

  namespace circular_inclusion {
\end_layout

\begin_layout Plain Layout

    class Pressure;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class benchmark::circular_inclusion::Pressure : public cigma::Function {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

    Pressure() {}
\end_layout

\begin_layout Plain Layout

    ~Pressure() {}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    virtual void init() { }
\end_layout

\begin_layout Plain Layout

    virtual FunctionType getType() const { return Function::GeneralType;
 }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    virtual int n_dim() { return 2; }
\end_layout

\begin_layout Plain Layout

    virtual int n_rank() { return 1; }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    virtual bool eval(double *x, double *y) {
\end_layout

\begin_layout Plain Layout

        const double R = 0.1;
\end_layout

\begin_layout Plain Layout

        const double mu_m = 1;
\end_layout

\begin_layout Plain Layout

        const double mu_i = 2;
\end_layout

\begin_layout Plain Layout

        const double mag_shear = 1.0;
\end_layout

\begin_layout Plain Layout

        const double C = 4*mag_shear*(mu_m*(mu_i-mu_m)/(mu_i+mu_m))*R*R;
\end_layout

\begin_layout Plain Layout

        const double xc = 0.0;
\end_layout

\begin_layout Plain Layout

        const double yc = 0.0;
\end_layout

\begin_layout Plain Layout

        const double dx = x[0] - xc;
\end_layout

\begin_layout Plain Layout

        const double dy = y[0] - yc;
\end_layout

\begin_layout Plain Layout

        const double r2 = dx*dx + dy*dy;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        if (r2 < R*R) {
\end_layout

\begin_layout Plain Layout

            value[0] = 0.0;
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

            double theta = atan2(dy, dx);
\end_layout

\begin_layout Plain Layout

            value[0] = (C/r2) * cos(2*theta);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        return true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
One additional step must be taken before we can use the name 
\family typewriter
bm.circular_inclusion.pressure
\family default
 on the Cigma command line.
 We must instantiate our new C++ class, and register it under an assigned
 name in the constructor defined in the 
\family typewriter
FunctionRegistry.cpp
\family default
 source file.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Assigning the name 
\family typewriter
bm.circular_inclusion
\family default
 to our analytic function.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

FunctionRegistry::FunctionRegistry()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  //
\end_layout

\begin_layout Plain Layout

  // ...
 other definitions
\end_layout

\begin_layout Plain Layout

  //
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  typedef benchmark::circular_inclusion::Pressure PressureFn1;
\end_layout

\begin_layout Plain Layout

  shared_ptr<PressureFn1> pressure1(new PressureFn1());
\end_layout

\begin_layout Plain Layout

  this->addFunction(
\begin_inset Quotes eld
\end_inset

bm.circular_inclusion.pressure
\begin_inset Quotes erd
\end_inset

, pressure1);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Now that we have an analytic expression for the pressure, we would like
 to obtain an approximate numerical solution to this circular inclusion
 problem.
 For this purpose we can use Gale, a CIG code for long-term crustal dynamics.
 Since the analytic formula for the velocity field is more complicated than
 the analytic formula for the pressure, we will simply expand the domain
 and use the far-field approximation of the velocity field in order to impose
 the kinematic boundary conditions in Gale,
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
v_{x} & = & +\dot{\epsilon}x\\
v_{y} & = & -\dot{\epsilon}y\end{eqnarray}

\end_inset

Since we expect our solution to vary as 
\begin_inset Formula $p\sim1/r^{2}$
\end_inset

, we target an error of 
\begin_inset Formula $0.01\%$
\end_inset

 by enlarging the domain under consideration to about 80 times the radius
 of the inclusion.
 This results in the final domain 
\begin_inset Formula $\Omega=[0,8]^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/out/fig_pressure_512.png
	lyxscale 40
	scale 22

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Pressure field for circular inclusion problem, with resolution of 
\begin_inset Formula $512\times512$
\end_inset

 elements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, we'd like to see how well the Gale solutions converge to a common
 answer by comparing each other against the highest resolution field available.
 Since we only have three solutions, that leaves us with only two meaningful
 comparisons,
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
    -a 512_8/fields.00000.pvts:PressureField 
\backslash

\end_layout

\begin_layout LyX-Code
    -b 128_8/fields.00000.pvts:PressureField 
\backslash

\end_layout

\begin_layout LyX-Code
    -o inclusion.h5:/error_pressure_512_128
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
    -a 512_8/fields.00000.pvts:PressureField 
\backslash

\end_layout

\begin_layout LyX-Code
    -b 256_8/fields.00000.pvts:PressureField 
\backslash

\end_layout

\begin_layout LyX-Code
    -o circ_inc.h5:/error_pressure_512_256
\end_layout

\begin_layout Standard
whose results we summarize in the following Table.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $||p_{n}-p_{512}||_{L_{2}}/\sqrt{V}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.088388
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0040745
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.044194
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0015786
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

from which we can estimate the order of convergence 
\begin_inset Formula $\alpha=\log(0.00158/0.00407)/\log(0.0442/0.0884)=1.36$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Processing the local error fields stored in 
\family typewriter
circ_inc.h5
\family default
, we obtain the following plots,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/out/fig_full_log_error_pressure_512_128_512_256.png
	lyxscale 40
	scale 25

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Errors in pressure field for 
\begin_inset Formula $128\times128$
\end_inset

, and 
\begin_inset Formula $256\times256$
\end_inset

 cases, relative to the 
\begin_inset Formula $512\times512$
\end_inset

 case, shown over the entire domain.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/out/fig_inc_log_error_pressure_512_128_512_256.png
	lyxscale 40
	scale 25

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Errors in pressure field for 
\begin_inset Formula $128\times128$
\end_inset

, and 
\begin_inset Formula $256\times256$
\end_inset

 cases, relative to the 
\begin_inset Formula $512\times512$
\end_inset

 case, shown near the inclusion.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we compare each of the three pressure fields obtained with Gale against
 the analytical formula for the pressure given earlier.
 We accomplish that by invoking the following bash command line,
\end_layout

\begin_layout LyX-Code
$ for r in 512 256 128; do
\end_layout

\begin_layout LyX-Code
    cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
      -a ${r}_8/fields.00000.pvts:PressureField 
\backslash

\end_layout

\begin_layout LyX-Code
      -b 
\series bold
bm.circular_inclusion.pressure
\series default
 
\backslash

\end_layout

\begin_layout LyX-Code
      -o inclusion.h5:/errror_pressure_${r}
\end_layout

\begin_layout LyX-Code
  done
\end_layout

\begin_layout Standard
whose output we summarize in the following table, 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $||p_{n}-p||_{L_{2}}/\sqrt{V}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.088388
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0050388
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.044194
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0036636
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0022097
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0024535
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

from which we can obtain the order of convergence 
\begin_inset Formula $\alpha=0.5$
\end_inset

, via a power-law regression analysis.
 Such a low value of 
\begin_inset Formula $\alpha$
\end_inset

 is expected since the pressure function we are solving has a discontinuity
 across the inclusion boundary.
\end_layout

\begin_layout Standard
After processing the errors in 
\family typewriter
inclusion.h5
\family default
 with the utility program 
\family typewriter
visualize-errors
\family default
, we obtain the following plots of the pressure field differences, 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/out/fig_full_log_error_pressure_256_512.png
	lyxscale 40
	scale 25

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Errors in pressure field for 
\begin_inset Formula $256\times256$
\end_inset

 and 
\begin_inset Formula $512\times512$
\end_inset

 element resolutions, relative to the analytic formula, shown over the entire
 domain.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/bm3/out/fig_inc_log_error_pressure_256_512.png
	lyxscale 40
	scale 25

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Errors in pressure field for 
\begin_inset Formula $256\times256$
\end_inset

 and 
\begin_inset Formula $512\times512$
\end_inset

 element resolutions, relative to the analytic formula, shown near the inclusion.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only appreciable change between these two plots happens in the region
 near the inclusion boundary, which becomes slightly more resolved spatially.
 Also, in contrast to the previous two sections, we do not detect much of
 a color shift between two plots, even though the 
\begin_inset Formula $L_{2}$
\end_inset

 global error is indeed decreasing.
 This is due to the fact that the error remains large near the inclusion
 with approximately the same maximum value, making it harder to see any
 variation in the local error field.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In summary, we have observed that the error is large near that region because
 the continuous elements used by Gale cannot properly resolve the pressure
 discontinuity at the surface of the inclusion.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In summary, we have observed that for this problem the 
\begin_inset Formula $L_{2}$
\end_inset

 global error does indeed decrease as we increase the mesh resolution, but
 it does not do so at the optimal rate.
 This indicates that the numerical scheme used to obtain these solutions
 is not completely accurate.
 Note that many numerical codes that solve Stokes flow, Gale included, assume
 that the pressure, velocity, and viscosity fields are continuous, an assumption
 that is violated for this particular problem.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Strikeslip Benchmark Convergence
\end_layout

\begin_layout Plain Layout
This benchmark problem computes the viscoelastic (Maxwell) relaxation of
 stresses from a single, finite strike-slip earthquake in 3D without gravity.
 In order to obtain several data points, we use the CUBIT mesh generator
 to create a sequence of meshes with a 1.2 refinement ratio on which to solve.
 In this case, we also calculate the displacement field over 100 timesteps,
 saving every 10th field.
\end_layout

\begin_layout LyX-Code
$ export a=hex8_0500m
\end_layout

\begin_layout LyX-Code
$ export b=hex8_1000m
\end_layout

\begin_layout LyX-Code
$ export d=displacements
\end_layout

\begin_layout LyX-Code
$ export steps=`seq -f '%04g' 0 10 100`  # generates list 0000 0010 0020
 ...
 0100
\end_layout

\begin_layout LyX-Code
$ for n in ${steps}; do
\end_layout

\begin_layout LyX-Code
    for b in 
\begin_inset Quotes eld
\end_inset

hex8_1000m hex8_0833m hex8_0694m hex8_0578m
\begin_inset Quotes erd
\end_inset

; do
\end_layout

\begin_layout LyX-Code
      echo 
\begin_inset Quotes eld
\end_inset

Calculating ${a}-${b}-${n}
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
      cigma compare 
\backslash

\end_layout

\begin_layout LyX-Code
        -a strikeslip_${a}_t${n}.vtk:${d} 
\backslash

\end_layout

\begin_layout LyX-Code
        -b strikeslip_${b}_t${n}.vtk:${d} 
\backslash

\end_layout

\begin_layout LyX-Code
        -o 
\begin_inset Quotes eld
\end_inset

strikeslipnog.h5:/${d}-${a}-${b}-${n}
\begin_inset Quotes erd
\end_inset

 
\backslash

\end_layout

\begin_layout LyX-Code
        --verbose
\end_layout

\begin_layout LyX-Code
    done
\end_layout

\begin_layout LyX-Code
  done
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Input and Output
\end_layout

\begin_layout Section
Supported File Formats
\end_layout

\begin_layout Standard
Cigma can understand a number of file formats, depending on how it is configured
 (see Chapter 2).
 By default it will read and write all information in binary form as HDF5
 files, which is a format optimal for archiving data with minimal redundancy.
 VTK files are also sometimes used by finite element software, due to the
 ease with which the solution fields can be visualized.
 Lastly, ExodusII mesh files generated by the CUBIT mesh generation package
 can also be used directly as integration meshes.
\end_layout

\begin_layout Standard
The most flexible way to store your arrays will be to use an HDF5 file (with
 extension 
\family typewriter
.h5
\family default
), which will allow you to organize your arrays in a hierarchy.
 The 
\family typewriter
h5attr
\family default
 allows you to add or modify any scalar metadata attributes to any HDF5
 group or array.
 
\end_layout

\begin_layout Standard
You can also use a simple text file (with extension 
\family typewriter
.dat
\family default
) containing a single array in row-column format.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.h5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input/output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDF5 Format
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.dat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input/output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Text Format
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.vtk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input/output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legacy VTK Format
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.vtu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VTK File for Unstructured Datasets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.vts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VTK File for Structured Datasets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.vtr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VTK File for Rectilinear Datasets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.exo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exodus Mesh Format
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of Cigma's file formats
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Data Formats
\end_layout

\begin_layout Standard
The basic data structure is a two-dimensional array of values, stored in
 a contiguous format as shown below:
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (TODO: why only 2D arrays, how about 3D arrays?)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(m,n)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{11},a_{12},\ldots,a_{1n}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{21},a_{22},\ldots,a_{2n}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\cdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{m1},a_{m2},\ldots,a_{mn}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
This layout is sufficient for describing both 2- and 3-dimensional data.
 Note the second index in this array varies the fastest, so that data often
 referenced together remains together in memory as well.
\end_layout

\begin_layout Subsection
Node Coordinates
\end_layout

\begin_layout Standard
On a mesh with 
\begin_inset Formula $n_{no}$
\end_inset

 node coordinates, which are specified on a global coordinate system, we
 have,
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{no},3)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Coordinates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{1},y_{1},z_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{2},y_{2},z_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{n_{no}},y_{n_{no}},z_{n_{no}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{no},2)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2-D Coordinates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{1},y_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{2},y_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{n_{no}},y_{n_{no}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Element Connectivity
\end_layout

\begin_layout Standard
Mesh connectivity is specified at the element-block level.
 On a given block, we only consider a single element type, which allows
 us to store the global node ids into a contiguous array of integers.
 Multiple blocks are specified separately, and they all reference the same
 node ids into the node coordinates table.
\end_layout

\begin_layout Standard
In general, if our block contains 
\begin_inset Formula $k$
\end_inset

 elements with 
\begin_inset Formula $m$
\end_inset

-degrees of freedom each, then the connectivity array defining our element
 block has the form
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(k,m)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Connectivity Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{11},n_{12},\ldots,n_{1m}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{21},n_{22},\ldots,n_{2m}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{k1},n_{k2},\ldots,n_{km}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
For the element types defined in Cigma, the values for 
\begin_inset Formula $m$
\end_inset

 are as follows.
 Note that the total number of degrees of freedom depends on the rank of
 the specific function being represented.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (TODO: update table)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scalar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tensor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tet4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tet10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hex8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hex20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hex27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Similarly for the 2D elements, we have
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2D Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scalar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tensor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tri3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quad4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Field Variables
\end_layout

\begin_layout Standard
A field variable represents one of the functions that we can evaluate, and
 is typically stored over a series of timesteps.
 The data for a field variable consists of snapshots through time, which
 are stored as separate arrays.
 A value for each degree of freedom is provided on the global list of nodes
 in the mesh.
 The ordering must be the same as the ordering of the node coordinates.
\end_layout

\begin_layout Subsection
Shape Function Values
\end_layout

\begin_layout Standard
In certain circumstances you may be able to provide your custom reference
 element by simply providing the appropriate 
\begin_inset Formula $n$
\end_inset

 shape function values to be used at the expected integration points.
 This is most useful when you are using the same mesh for both the integration
 mesh and the array.
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shape Function Values: 
\begin_inset Formula $(n,Q)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jacobian Determinant: 
\begin_inset Formula $(Q,1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integration Point 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{1}(\vec{\xi}_{1}),N_{2}(\vec{\xi}_{1}),\ldots,N_{n}(\vec{\xi}_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $J(\vec{\xi}_{1})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integration Point 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{1}(\vec{\xi}_{2}),N_{2}(\vec{\xi}_{2}),\ldots,N_{n}(\vec{\xi}_{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $J(\vec{\xi}_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integration Point 
\begin_inset Formula $Q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{1}(\vec{\xi}_{Q}),N_{2}(\vec{\xi}_{Q}),\ldots,N_{n}(\vec{\xi}_{Q})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $J(\vec{\xi}_{Q})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Integration Rules
\end_layout

\begin_layout Standard
As mentioned in Section 4.3.2
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (TODO: x-ref, do you really mean ch4?)
\end_layout

\end_inset

, an integration rule is specified by a list of points and associated weights.
 The points should be specified on the natural coordinate system used by
 the corresponding reference element.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Weights: 
\begin_inset Formula $(Q,1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Points: 
\begin_inset Formula $(Q,n_{dim})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2D Points: 
\begin_inset Formula $(Q,2)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Points: 
\begin_inset Formula $(Q,3)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rule Definition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $w_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{\xi}_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{1},\eta_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{1},\eta_{1},\zeta_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $w_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{\xi}_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{2},\eta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{2},\eta_{2},\zeta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $w_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{\xi}_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{Q},\eta_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\xi_{Q},\eta_{Q},\zeta_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsection
Integration Points and Values
\end_layout

\begin_layout Standard
Given a mesh and an integration rule, we can map the integration points
 on each element into a possibly large set of global points.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Points: 
\begin_inset Formula $(n_{pts},n_{dim})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2D Points: 
\begin_inset Formula $(n_{pts},2)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Points: 
\begin_inset Formula $(n_{pts},3)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Coordinates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{x}_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{1},y_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{1},y_{1},z_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{x}_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{2},y_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{2},y_{2},z_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{x}_{n_{pts}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{n_{pts}}y_{n_{pts}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{n_{pts}},y_{n_{pts}},z_{n_{pts}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The result of an evaluation will depend on the rank of the function being
 evaluated, as indicated in the table below.
 Note that the fastest varying dimension of the array contains the components
 of the function value at each point.
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Evaluated Quantity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resulting Array Shape
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scalar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{pts},1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2D Vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{pts},2)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{pts},3)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2D Tensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{pts},3)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Tensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n_{pts},6)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Local 
\begin_inset Formula $L_{2}$
\end_inset

-errors
\end_layout

\begin_layout Standard
Since our norm reduces integrals over cells to a single scalar value, the
 result of a comparison will result in a simple scalar array for each element
 block examined.
 Note that element blocks used in the integration process belong to the
 integration mesh, which may differ from the associated mesh to either function.
\end_layout

\begin_layout Standard
Thus, for each element block containing 
\begin_inset Formula $k$
\end_inset

 cells, we have the output array
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(k,1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varepsilon_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varepsilon_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varepsilon_{k}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
These error values may be combined in the following form: 
\begin_inset Formula \[
\varepsilon_{block}=\sqrt{\varepsilon_{1}^{2}+\varepsilon_{2}^{2}+\cdots+\varepsilon_{k}^{2}}\]

\end_inset

The final global error norm maybe obtained by simply summing over all element
 blocks that partition the domain of interest:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\varepsilon_{global}=\sqrt{\sum_{block}\varepsilon_{block}^{2}}\]

\end_inset

Currently, this last calculation can only be performed using a problem-specific
 post-processing script, since Cigma will only perform comparisons on a
 single element block.
\end_layout

\begin_layout Section
Input Files
\end_layout

\begin_layout Standard
In Section A.2
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (TODO: x-ref)
\end_layout

\end_inset

, we examined what kinds of objects we will be accessing, so now let's discuss
 the actual layout in the files in which these objects will be stored.
\end_layout

\begin_layout Subsection
HDF5
\end_layout

\begin_layout Standard
HDF5 files are binary files encoded in a data format designed to store large
 amounts of scientific data in a portable and self-describing way.
 
\end_layout

\begin_layout Standard
The internal organization of a typical HDF5 file consists of a hierarchical
 structure similar to a UNIX file system.
 Two types of primary objects, 
\emph on
groups
\emph default
 and 
\emph on
datasets
\emph default
, are stored in this structure.
 A group contains instances of zero or more groups or datasets, while a
 dataset stores a multi-dimensional array of data elements.
 In a sense, datasets are analogous to files in a traditional file system,
 and groups are analagous to folders.
 One important difference, however, is that you can attach supporting metadata
 to both kinds of objects.
 These associated metadata are known as 
\emph on
attributes.
\end_layout

\begin_layout Standard
A dataset is physically stored in two parts: a header and a data array.
 The header contains miscellaneous metadata describing the dataset as well
 as information that is needed to interpret the array portion of the dataset.
 Essentially, it includes the name, datatype, dataspace, and storage layout
 of the dataset.
 The name is a text string identifying the dataset.
 The datatype describes the type of the data array elements.
 The dataspace defines the dimensionality of the dataset, i.e., the size and
 shape of the multi-dimensional array.
\end_layout

\begin_layout Standard
With Cigma you always provide an explicit path to specific datasets, so
 you have a fair amount of flexibility in how you organize datasets into
 groups inside your HDF5 files.
 For example, a typical file could have the following structure,
\end_layout

\begin_layout LyX-Code
file.h5
\end_layout

\begin_layout LyX-Code

\backslash
__ model
\end_layout

\begin_layout LyX-Code
    |__ mesh
\end_layout

\begin_layout LyX-Code
    |   |__ coordinates    [nno x nsd]
\end_layout

\begin_layout LyX-Code
    |   
\backslash
__ connectivity   [nel x ndof]
\end_layout

\begin_layout LyX-Code
    
\backslash
__ variables
\end_layout

\begin_layout LyX-Code
        |__ temperature
\end_layout

\begin_layout LyX-Code
        |   |__ step00000  [nno x 1]
\end_layout

\begin_layout LyX-Code
        |   |__ step00010  [nno x 1]
\end_layout

\begin_layout LyX-Code
        |   
\backslash
...
\end_layout

\begin_layout LyX-Code
        |__ displacement
\end_layout

\begin_layout LyX-Code
        |   |__ step00000  [nno x 3]
\end_layout

\begin_layout LyX-Code
        |   |__ step00010  [nno x 3]
\end_layout

\begin_layout LyX-Code
        |   
\backslash
...
\end_layout

\begin_layout LyX-Code
        
\backslash
__ velocity
\end_layout

\begin_layout LyX-Code
            |__ step00000  [nno x 3]
\end_layout

\begin_layout LyX-Code
            |__ step00010  [nno x 3]
\end_layout

\begin_layout LyX-Code
            
\backslash
...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
where the structure of the mesh does not change from timestep to timestep.
\end_layout

\begin_layout Standard
Alternatively, a file which stores data associated with a mesh that changes
 over time would have a different structure,
\end_layout

\begin_layout LyX-Code
file.h5
\end_layout

\begin_layout LyX-Code

\backslash
__ model
\end_layout

\begin_layout LyX-Code
    |__ step00000
\end_layout

\begin_layout LyX-Code
    |   |__ mesh
\end_layout

\begin_layout LyX-Code
    |   |   |__ coordinates
\end_layout

\begin_layout LyX-Code
    |   |   
\backslash
__ connectivity
\end_layout

\begin_layout LyX-Code
    |   |__ variables
\end_layout

\begin_layout LyX-Code
    |       |__ temperature
\end_layout

\begin_layout LyX-Code
    |       |__ displacement
\end_layout

\begin_layout LyX-Code
    |       
\backslash
__ velocity
\end_layout

\begin_layout LyX-Code
    |__ step00010
\end_layout

\begin_layout LyX-Code
    |   |__ mesh
\end_layout

\begin_layout LyX-Code
    |   |   |__ coordinates
\end_layout

\begin_layout LyX-Code
    |   |   
\backslash
__ connectivity
\end_layout

\begin_layout LyX-Code
    |   |__ variables
\end_layout

\begin_layout LyX-Code
    |       |__ temperature
\end_layout

\begin_layout LyX-Code
    |       |__ displacement
\end_layout

\begin_layout LyX-Code
    |       
\backslash
__ velocity
\end_layout

\begin_layout LyX-Code
    
\backslash
__ ...
\end_layout

\begin_layout Standard
where we have allowed for each.
\end_layout

\begin_layout Standard
To summarize, Cigma requires you to specify a full path to a specific dataset.
 Moreover, by attaching a small amount of metadata to your datasets, it
 becomes possible to reduce the amount of information that must be provided
 to the comparison routine, such as what mesh to use in conjunction with
 a given set of coefficients, and which set of shape functions to use in
 the respective evaluations.
\end_layout

\begin_layout Description
MeshLocation is a string representing the HDF5 path pointing to the mesh
 group which contains the coordinates and connectivity datasets.
 This attribute should be attached to the array corresponding to your degrees
 of freedom (shape function coefficients).
\end_layout

\begin_layout Description
CellType is a string identifier used to determine which shape functions
 to use for interpolating values inside the element (e.g., tet4, hex8, quad4,
 tri3, ...).
 This attribute should be attached to the mesh group that contains the coordinat
es and connectivity datasets.
\end_layout

\begin_layout Standard
Even if you forgot to set these attributes when creating your HDF5 datasets,
 setting or changing them can be done easily by using the 
\family typewriter
h5attr
\family default
 utility included in Cigma.
 For example, the following command would let Cigma know that the path 
\family typewriter
/model/mesh
\family default
 corresponds to a linear tetrahedral mesh
\end_layout

\begin_layout LyX-Code
$ h5attr model.h5:/model/mesh CellType tet4
\end_layout

\begin_layout Standard
Likewise, the following command would associate the mesh 
\family typewriter
/model/mesh
\family default
 with the field coefficients 
\family typewriter
/model/
\begin_inset Newline newline
\end_inset

variables/temperature/step00000
\end_layout

\begin_layout LyX-Code
$ h5attr model.h5:/model/variables/temperature/step00000 MeshLocation /model/mesh
 
\end_layout

\begin_layout Standard
Setting the MeshLocation attribute in this manner has the advantage that
 corresponding mesh options can be omitted when calling 
\family typewriter
cigma compare
\family default
 on the command line.
\end_layout

\begin_layout Subsection
VTK
\end_layout

\begin_layout Standard
For detailed information on this format, you may want to refer to Visualization
 ToolKit's File Formats 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

www.vtk.org/pdf/file-formats.pdf
\end_layout

\end_inset

 document.
 Here we will only note that using VTK files is convenient due to the fact
 that the mesh is always required by the file format.
 You typically only need to provide the file name, and the name of the dataset
 inside the file that you wish to use in the comparison operation, although
 you may safely omit the dataset name if your VTK file contains only a single
 point dataset.
 Perhaps one of the most important things to keep in mind, when using VTK
 files with the current version of Cigma, is that unstructured datasets
 will need to consist of cells of a single type.
\end_layout

\begin_layout Subsection
Text
\end_layout

\begin_layout Standard
The text files we use in Cigma consist of a simple list of numbers in ASCII
 format whose layout corresponds exactly to the simple array layout discussed
 earlier in Appendix A.2.
 The first line of the file contains the dimensions of the array, just two
 integers separated by whitespace.
 The rest of the file specifies the array data, and must contain as many
 numbers as the product of the two dimensions given in the first line, all
 separated by whitespace.
 These numbers should be formatted as integer or floating point, depending
 on whether you are describing coordinates or coefficients, or whether you
 are referring to a connectivity array.
\end_layout

\begin_layout Standard
Some restrictions apply when providing data in text format, mostly because
 you can only specify a single element block in a text file containing connectiv
ity information.
 Operations involving a larger number of blocks must use data in the format
 described in Appendix A.3.1.
\end_layout

\begin_layout Standard
Another point worthy of mention is that arrays must be given in two-dimensional
 form, i.e., two integers are always expected in the first line.
 Therefore, when specifying a one-dimensional array, such as a list of weights
 corresponding to an integration rule, the second array dimension must be
 1.
\end_layout

\begin_layout Section
Output Files
\end_layout

\begin_layout Standard
For the most part, there are three different kinds of output files you can
 use, as already summarized in Appendix A.1.
 Switching output formats is as simple as changing the extension of the
 output file name.
 
\end_layout

\begin_layout Standard
The result of all comparisons always consists of a one dimensional list
 of scalars, one for each element in the underlying discretization used
 to approximate the 
\begin_inset Formula $L_{2}$
\end_inset

-norm integral.
 You can output these error values directly into a VTK file, in which case
 the array will be stored in the Cell Data section of the output file.
 Since Cigma includes a post-processing utility called 
\family typewriter
visualize-errors
\family default
 that can convert HDF5 errors into VTK files, we recommend that you use
 HDF5 files to store the result of your comparisons.
 Note that HDF5 files will not be overwritten when used for output, which
 allows you to store multiple datasets inside the same HDF5 file without
 keeping redundant mesh information as is typically the case when using
 VTK files.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Meshes
\end_layout

\begin_layout Plain Layout
Here we describe the mesh format.
\end_layout

\begin_layout Section
Output Quantities
\end_layout

\begin_layout Chapter
Mesh Format
\end_layout

\begin_layout Plain Layout
In this chapter we describe the mesh format used to store meshes.
\end_layout

\begin_layout Section
Element Types
\end_layout

\begin_layout Plain Layout
We give we assume that within the block we have a single element type, chosen
 from this list.
\end_layout

\begin_layout Description
CellType This attribute defines the geometrical type of the reference element
 associated with a particular Element Block
\end_layout

\begin_deeper
\begin_layout Description
tri3 Three-node triangle.
\end_layout

\begin_layout Description
tri6 Six-node second order triangle.
 Three nodes associated with the vertices, and three with the edges.
\end_layout

\begin_layout Description
quad4 Four-node quadrangle.
\end_layout

\begin_layout Description
pixel4 Four-node quadrangle with a different node ordering.
\end_layout

\begin_layout Description
tet4 Four-node tetrahedron.
\end_layout

\begin_layout Description
tet10 Ten-node second order tetrahedron.
 Four nodes associated with the vertices, and six with the edges.
\end_layout

\begin_layout Description
hex8 Eight-node hexahedron.
\end_layout

\begin_layout Description
voxel8 Eight-node hexahedron with different node ordering.
\end_layout

\end_deeper
\begin_layout Section
Node Ordering
\end_layout

\begin_layout Plain Layout
The ordering of the columns in the connectivity array corresponds to the
 node ordering.
 The reference elements are defined as follows.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
