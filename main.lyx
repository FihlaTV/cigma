#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The CIG Model Analyzer (Cigma) consists of a general suite of tools for
 comparing numerical models.
 CIG has developed Cigma in response to demand from the short-term tectonics
 community for an automated tool that is capable.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "cha:Error-Analysis"

\end_inset

Error Analysis
\end_layout

\begin_layout Standard
When solving differential equations representing physical systems of interest,
 we are often able to obtain a family of solutions by applying a variety
 of solution techniques.
 Sometimes an analytic method can be found, but most of the time we end
 up resorting to a numerical algorithm, such as the finite element method.
 Assessing the quality of these solutions is an important task, so we would
 like to develop a quantitative measure for indicating just how close our
 solutions approach the exact answer.
\end_layout

\begin_layout Standard
The simplest possible quantitative measure of the difference between two
 distinct functions consists of taking the pointwise difference at a common
 set of points.
 While no finite sample of points can perfectly represent a continuum of
 values, valuable information can be inferred from the statistics of the
 resulting set of differences.
 However, the functions we want to compare may not be defined at a common
 set of points.
 Unless we are able to interpolate the two functions on an intermediate
 set of points, this simple pointwise measure becomes inapplicable.
\end_layout

\begin_layout Standard
A very useful distance measure we can use is the 
\begin_inset Formula $L_{2}$
\end_inset

 norm, defined by the following integral
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\varepsilon=||u-v||_{L_{2}}=\sqrt{\int_{\Omega}||u(\vec{x})-v(\vec{x})||^{2}d\vec{x}}\end{equation}

\end_inset

where 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are the two functions defined on a global coordinate system.
 This gives us a single global estimate 
\begin_inset Formula $\varepsilon$
\end_inset

 representing the distance between the two functions 
\begin_inset Formula $u(\vec{x})$
\end_inset

 and 
\begin_inset Formula $v(\vec{x})$
\end_inset

.
 Alternatively, you may think of this as the size, or norm, of the 
\series bold
\emph on
residual field
\series default
\emph default
 
\begin_inset Formula $\rho(\vec{x})=u(\vec{x})-v(\vec{x})$
\end_inset

.
 This measure is useful because it is well known that solutions obtained
 with the finite element method converge only in a weak sense, as an average
 over a geometric region.
 In the rest of this chapter we will discuss the details involved in evaluating
 the above integral.
\end_layout

\begin_layout Standard
Another quantitative measure, which we won't discuss in this version of
 Cigma, is the energy norm.
 This norm is typically employed in 
\emph on
a posteriori
\emph default
 error analysis and is problem dependent.
 In general, the residual field used under this norm is defined in terms
 of the linearized equation from which the solution was obtained.
 Yet another interesting possibility would be to 
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
The functions that we discuss in this manual are assumed to be defined in
 a common region of space denoted by 
\begin_inset Formula $\Omega$
\end_inset

.
 Elements of 
\begin_inset Formula $\Omega$
\end_inset

 are written as 
\begin_inset Formula $\vec{x}$
\end_inset

, and the number of components in the corresponding value of 
\begin_inset Formula $f(\vec{x})$
\end_inset

, is said to be the 
\series bold
\emph on
rank
\series default
\emph default
 of the function 
\begin_inset Formula $f$
\end_inset

.
 Thus, 
\emph on
scalar functions
\emph default
 have a rank of 1, 
\emph on
vector functions
\emph default
 would have a rank of 2 or 3, and 
\emph on
tensor functions
\emph default
 would have a rank of 6 or 9.
\end_layout

\begin_layout Section
Integral Approximations
\end_layout

\begin_layout Standard
In order to evaluate the integral for our 
\begin_inset Formula $L_{2}$
\end_inset

 norm, we will need to define an integration mesh which partitions the common
 domain 
\begin_inset Formula $\Omega$
\end_inset

 on which our two functions are defined.
 We can then use a numerical approximation, or 
\series bold
\emph on
integration rule
\series default
\emph default
, on each of the discrete cell elements 
\begin_inset Formula $\Omega_{i}$
\end_inset

 of our partition.
 Each of these cell integrals of the continuous residual norm 
\begin_inset Formula $||\rho(\vec{x})||^{2}$
\end_inset

 can then be replaced by a weighed sum evaluated at a finite set of points.
 This integral will be valid up to a certain accuracy.
 In Chapter 5, we discuss in more detail how choose the location and values
 for the integration points and weights which give optimal accuracy.
\end_layout

\begin_layout Standard
Thus, in general, an integration rule with 
\begin_inset Formula $Q$
\end_inset

 points and weights that allows us to integrate the scalar function 
\begin_inset Formula $F(\vec{x})$
\end_inset

 is given by the equation
\begin_inset Formula \begin{equation}
\int_{\Omega_{i}}\ F(\vec{x})\ d\vec{x}\approx\sum_{q=1}^{Q}F(\vec{X_{q}})W_{q}\end{equation}

\end_inset

where the integration points 
\begin_inset Formula $\vec{X}_{q}$
\end_inset

 and integration weights 
\begin_inset Formula $W_{q}$
\end_inset

 depend on the integration region 
\begin_inset Formula $\Omega_{i}$
\end_inset

.
 As we will see in Chapter 7, one possibility is to pre-calculate these
 points and weights explicitly on a specific discretization.
 Thus, as discussed in more detail in Chapters 4 and 5, we will generally
 want to define a reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 which acts as a template for cells with the same geometric shape.
 We can achieve this by defining a 
\series bold
\emph on
reference map
\series default
\emph default
 
\begin_inset Formula $\chi_{i}:\hat{\Omega}\to\Omega_{i}$
\end_inset

 that describes how points in a specific cell 
\begin_inset Formula $\Omega_{i}$
\end_inset

 originate from the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 In this sense, the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 is said to define a 
\series bold
\emph on
local coordinate system
\series default
\emph default
 for the 
\begin_inset Formula $i$
\end_inset

-th cell 
\begin_inset Formula $\Omega_{i}.$
\end_inset


\end_layout

\begin_layout Standard
Note that a given discretization may contain cells of different shapes,
 which would require us to define an appropriate number of reference cells
 for each type of cell.
 However, for the purposes of this manual we may restrict the discussions
 in this manuals, without any loss of generality, to discretizations consisting
 of a single geometric shape.
 (XXX: reword this last sentence)
\end_layout

\begin_layout Standard
The advantage of this approach is readily apparent when one realizes that
 the integration points and weights can be calculated once and for all on
 the reference cell, and then reused for the other cells through the application
 of the corresponding reference map.
 In other words,
\begin_inset Formula \begin{eqnarray*}
\vec{X}_{q} & = & \chi_{i}(\vec{\xi}_{q})\\
W_{q} & = & w_{q}J_{i}(\vec{\xi}_{q})\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $\vec{\xi}_{q}$
\end_inset

 and 
\begin_inset Formula $w_{q}$
\end_inset

 are the optimal integration points and weights for the integration rule
 defined on the reference domain 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 Here, the factor 
\begin_inset Formula $J_{i}(\vec{\xi})=\det\ \left|\frac{d\chi_{i}}{d\vec{\xi}}\right|$
\end_inset

 is the Jacobian determinant of the transformation 
\begin_inset Formula $\chi_{i}$
\end_inset

.
 Recall that the index 
\begin_inset Formula $i$
\end_inset

 corresponds to the 
\begin_inset Formula $i$
\end_inset

-th cell 
\begin_inset Formula $\Omega_{i}$
\end_inset

, and the index 
\begin_inset Formula $q$
\end_inset

 ranges over the usual 
\begin_inset Formula $q=1,\ldots,Q$
\end_inset

.
\end_layout

\begin_layout Section
Interpolation Functions
\end_layout

\begin_layout Standard
Our two functions 
\begin_inset Formula $u(\vec{x})$
\end_inset

 and 
\begin_inset Formula $v(\vec{x})$
\end_inset

 are given in terms of the point
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

, and are said to be defined on a 
\series bold
\emph on
global coordinate system
\series default
\emph default
.
 Based on our discussion in Section 3.1, we see that we only need to know
 the values of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 at a finite set of global points in order to calculate an approximation
 to the 
\begin_inset Formula $L_{2}$
\end_inset

 norm of the residual field 
\begin_inset Formula $\rho=u-v$
\end_inset

.
\end_layout

\begin_layout Standard
Specifically, given a function 
\begin_inset Formula $f(\vec{x})$
\end_inset

 we must be able to calculate its values at exactly those integration points.
 If we know a formula or algorithm for 
\begin_inset Formula $f$
\end_inset

, then our task is easy.
 Alternatively, these values can be given explicitly as a finite list.
 In all other cases, we will need an interpolation scheme that allows us
 to calculate 
\begin_inset Formula $f$
\end_inset

 on any intermediate points.
 This ability is also important because we may want to increase the accuracy
 of our norm by using more integration points, and thus we will need to
 be able to evaluate our function 
\begin_inset Formula $f$
\end_inset

 at the new points.
\end_layout

\begin_layout Standard
In general, an interpolation scheme involves a set of known functions 
\begin_inset Formula $\phi_{j}(\vec{x})$
\end_inset

 that we can compute anywhere and a set of parameters 
\begin_inset Formula $c_{j}$
\end_inset

 that define how these known functions are combined.
 Usually, the relation between the parameters and the known functions is
 a linear combination, 
\begin_inset Formula \begin{equation}
f(\vec{x})=d_{1}\phi_{1}(\vec{x})+d_{2}\phi_{2}(\vec{x})+\cdots+d_{m}\phi_{m}(\vec{x})\end{equation}

\end_inset

where the parameters 
\begin_inset Formula $d_{j}$
\end_inset

, with 
\begin_inset Formula $j=1,\ldots,m$
\end_inset

, are also sometimes referred to as the 
\series bold
\emph on
degrees of freedom
\series default
\emph default
 of the function 
\begin_inset Formula $f$
\end_inset

.
 As described in Chapter 4, the functions 
\begin_inset Formula $\phi_{j}$
\end_inset

, also known as 
\series bold
\emph on
shape functions
\series default
\emph default
, must satisfy a number of conditions.
 Because the choice of shape functions affects how well the true solution
 is represented, the convergence of the numerical method used to obtain
 the solution, the optimal choice of shape functions is very problem dependent.
\end_layout

\begin_layout Standard
If we know the shape functions 
\begin_inset Formula $\phi_{j}$
\end_inset

 directly in terms of the global points 
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

, they are said to form a 
\series bold
\emph on
global interpolation scheme
\series default
\emph default
, and we may use Eq X directly to find the values of 
\begin_inset Formula $f(\vec{x})$
\end_inset

, and we may refer to the 
\begin_inset Formula $\phi_{j}$
\end_inset

as 
\emph on
global shape functions
\emph default
.
 Note that since we are working in the global coordinate system, we don't
 need the discretization of the domain 
\begin_inset Formula $\Omega$
\end_inset

.
 Examples of global shape functions include spherical harmonics, and ...
\end_layout

\begin_layout Standard
Perhaps a more typical case is when 
\begin_inset Formula $f(\vec{x})$
\end_inset

 is defined piecewise, on each discretization element 
\begin_inset Formula $\Omega_{i}$
\end_inset

.
 Because these cells partition the original domain by definition, a given
 point in our domain will be found in one and only one cell, which will
 have a local definition.
 That is, for a particular 
\begin_inset Formula $\vec{x}\in\Omega$
\end_inset

 we will be able to find a unique cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

, for some index 
\begin_inset Formula $e$
\end_inset

.
 We can refer to this as a 
\series bold
\emph on
local interpolation scheme
\series default
\emph default
.
\end_layout

\begin_layout Standard
See Chapter 5, for more details on the specific interpolation schemes available
 in Cigma.
\end_layout

\begin_layout Section
Global Error Measure
\end_layout

\begin_layout Standard
In this section we show the formula used by Cigma to compute the 
\begin_inset Formula $L_{2}$
\end_inset

 norm of the residual field 
\begin_inset Formula $\rho$
\end_inset

.
\end_layout

\begin_layout Standard
Suppose the domain 
\begin_inset Formula $\Omega$
\end_inset

 into an appropriate set of cells 
\begin_inset Formula $\Omega_{1},\Omega_{2},\ldots,\Omega_{n_{el}}$
\end_inset

, we can compute the global error 
\begin_inset Formula $\varepsilon^{2}$
\end_inset

 as a sum over localized cell contributions, 
\begin_inset Formula $\varepsilon^{2}=\sum_{e}\varepsilon_{e}^{2}$
\end_inset

, where each cell residual 
\begin_inset Formula $\varepsilon_{e}^{2}$
\end_inset

 is given by
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\varepsilon_{e}^{2} & = & \int_{\Omega_{e}}||u(\vec{x})-v(\vec{x})||^{2}d\vec{x}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In general, we won't be able to integrate each cell residual 
\begin_inset Formula $\varepsilon_{e}^{2}$
\end_inset

 exactly since either of the functions 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 may have an incompatible representation relative to the finite element
 space on each domain 
\begin_inset Formula $\Omega_{e}$
\end_inset

.
 However, we can still calculate an approximation of each cell residual
 by applying an appropriate quadrature rule with a tolerable truncation
 error 
\begin_inset CommandInset citation
LatexCommand cite
key "Encyclopaedia of Cubature Formulas 2005"

\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain an approximation to the integral of a function 
\begin_inset Formula $F(\vec{x})$
\end_inset

 over a cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

, we simply apply the quadrature rule with weights 
\begin_inset Formula $w_{e,1},w_{e,2},\ldots,w_{e,n_{Q}}$
\end_inset

 and integration points 
\begin_inset Formula $\vec{x}_{e,1},\vec{x}_{e,2},\ldots,\vec{x}_{e,n_{Q}}$
\end_inset

 appropriate for the physical element 
\begin_inset Formula $\Omega_{e}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\int_{\Omega_{e}}\ F(\vec{x})\ d\vec{x}=\sum_{q=1}^{n_{Q}}w_{e,q}F(\vec{x}_{e,q})\]

\end_inset


\end_layout

\begin_layout Standard
Applying this quadrature rule directly over the entire physical domain 
\begin_inset Formula $\Omega=\cup\Omega_{e}$
\end_inset

 gives us 
\begin_inset Formula \[
\int_{\Omega}\ F(\vec{x})\ d\vec{x}=\sum_{e=1}^{n_{el}}\sum_{q=1}^{n_{Q}}w_{e,q}F(\vec{x}_{e,q})\]

\end_inset


\end_layout

\begin_layout Standard
For efficiency reasons, it is undesirable in finite element applications
 to perform calculations in a global coordinate system.
 To avoid duplication of work, shape function evaluations may be performed
 once on a reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

 and then transformed back into the corresponding physical cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

 as needed.
\end_layout

\begin_layout Standard
To compute integrals of 
\begin_inset Formula $F$
\end_inset

 in a reference coordinate system, we need to apply a change of variables:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\int_{\Omega_{e}}\ F(\vec{x})\ d\vec{x}=\int_{\hat{\Omega}}\ F(\vec{x}_{e}(\vec{\xi}))J_{e}(\vec{\xi})\ d\vec{\xi}\]

\end_inset

where 
\color none
the additional factor 
\begin_inset Formula $J_{e}(\vec{\xi})=\det\left[\frac{d\vec{x}_{e}}{d\vec{\xi}}\right]$
\end_inset

 is the Jacobian determinant of the reference map 
\begin_inset Formula $\vec{x}_{e}(\vec{\xi}):\hat{\Omega}\to\Omega_{e}$
\end_inset

.
 This map describes how the physical points 
\begin_inset Formula $\vec{x}\in\Omega_{e}$
\end_inset

 are transformed from the reference points 
\begin_inset Formula $\vec{\xi}\in\hat{\Omega}$
\end_inset

.
 Put another way, the inverse reference map 
\color inherit

\begin_inset Formula $\vec{\xi}=\vec{x}_{e}^{-1}(\vec{x})$
\end_inset

 tells us how the physical domain 
\begin_inset Formula $\Omega_{e}$
\end_inset

 maps into the reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
\end_layout

\begin_layout Standard
At this point, we can assume without loss of generality that every physical
 cell 
\begin_inset Formula $\Omega_{e}$
\end_inset

 can be derived from a single reference cell 
\begin_inset Formula $\hat{\Omega}$
\end_inset

, so that our quadrature rule becomes simply a set of weights 
\begin_inset Formula $w_{1},\ldots,w_{n_{Q}}$
\end_inset

 and points 
\begin_inset Formula $\vec{\xi}_{1},\ldots,\vec{\xi}_{n_{Q}}$
\end_inset

 over 
\begin_inset Formula $\hat{\Omega}$
\end_inset

.
 After changing variables, we end up with the final form of the quadrature
 rule that we can use to integrate the global residual field:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\int_{\hat{\Omega}}\ F(\vec{x}_{e}(\vec{\xi}))J_{e}(\vec{\xi})\ d\vec{\xi}=\sum_{q=1}^{n_{Q}}w_{q}F(\vec{x}_{e}(\vec{\xi}_{q}))J_{e}(\vec{\xi}_{q})\]

\end_inset


\end_layout

\begin_layout Standard
If we let 
\begin_inset Formula $F(\vec{x})=||u(\vec{x})-v(\vec{x})||^{2}$
\end_inset

 in the above expression, we can find the cell residual contribution over
 
\begin_inset Formula $\Omega_{e}$
\end_inset

 from
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\varepsilon_{e}^{2} & = & \int_{\Omega_{e}}\ ||u(\vec{x})-v(\vec{x})||^{2}\ d\vec{x}\\
 & = & \int_{\hat{\Omega}}\ ||u(\vec{x}_{e}(\vec{\xi}))-v(\vec{x}_{e}(\vec{\xi}))||^{2}J_{e}(\vec{\xi})\ d\vec{\xi}\\
 & = & \sum_{q=1}^{\mathrm{n_{Q}}}w_{q}||u(\vec{x}_{e}(\vec{\xi}_{q}))-v(\vec{x}_{e}(\vec{\xi}_{q}))||^{2}J_{e}(\vec{\xi}_{q})\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The global error 
\begin_inset Formula $\varepsilon=\sqrt{\sum_{e}\varepsilon_{e}^{2}}$
\end_inset

 is then approximated by the expression
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula \begin{eqnarray*}
\varepsilon & = & \sqrt{\sum_{e=1}^{\mathrm{n_{el}}}\sum_{q=1}^{\mathrm{n_{Q}}}w_{q}||u(\vec{x}_{e}(\vec{\xi}_{q}))-v(\vec{x}_{e}(\vec{\xi}_{q}))||^{2}J_{e}(\vec{\xi}_{q})}\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

We use this final form to calculate the global and localized errors on arbitrary
 discretizations.
\end_layout

\begin_layout Section
Comparing Residuals
\end_layout

\begin_layout Standard
For comparing errors of different solutions, you can normalize the global
 error by the norm of the exact solution.
 For a family of solutions 
\begin_inset Formula $u_{h}(\vec{x})$
\end_inset

, parametrized by the the maximum element size 
\begin_inset Formula $h$
\end_inset

 of the underlying discretization, and an exact solution 
\begin_inset Formula $u(\vec{x})$
\end_inset

, this normalized error is given by
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\varepsilon_{rel} & = & \frac{||u-u_{h}||_{L_{2}}}{||u||_{L_{2}}}\\
 & = & \frac{\int_{\Omega}||u(\vec{x})-u_{h}(\vec{x})||^{2}d\vec{x}}{\int_{\Omega}||u(\vec{x})||^{2}d\vec{x}}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This normalized error can be interpreted as the average error in the physical
 quantity being evaluated, so that a value of 0.01 corresponds to a 1% averaged
 error.
\end_layout

\begin_layout Standard
Even if the exact solution is not currently known, this normalized error
 may be used to test the accuracy between two or more numerical solutions,
 defined on successively refined meshes.
\end_layout

\begin_layout Section
Convergence Rates
\end_layout

\begin_layout Standard
Even if the exact solution 
\begin_inset Formula $u(\vec{x})$
\end_inset

 is not known, but we have calculated a family of solutions 
\begin_inset Formula $u_{h}(\vec{x})$
\end_inset

 on discrete meshes, we may calculate a convergence rate by using the standard
 error estimate 
\begin_inset Formula $||u-u_{h}||_{p}\leq Ch^{\alpha},$
\end_inset

where 
\begin_inset Formula $C$
\end_inset

 is independent of both 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

.
 This error bound holds problems
\end_layout

\begin_layout Section
Uses in Benchmarking
\end_layout

\begin_layout Standard
As we saw in Section 3.5, it is easier to calculate the convergence rate
 on a sequence of meshes if we have access to the exact solution.
 
\end_layout

\begin_layout Section
Citation
\end_layout

\begin_layout Standard
Computational Infrastructure for Geodynamics (CIG) is making this source
 code available to you in the hope that the software will enhance your research
 in geophysics.
 This is a brand-new code and at present no papers are published or press.
 Please cite this manual as follows:
\end_layout

\begin_layout Itemize
Armendariz, L., and S.
 Kientz.
 
\emph on
Cigma User Manual.

\emph default
 Pasadena, CA: Computational Infrastructure of Geodynamics, 2008.
 URL: geodynamics.org/cig/software/cs/cigma/cigma.pdf
\end_layout

\begin_layout Standard
CIG requests that in your oral presentations and in your papers that you
 indicate your use of this code and acknowledge the author of the code and
 CIG 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Support
\end_layout

\begin_layout Standard
Cigma development is based upon work supported by the National Science Foundatio
n under Grant No.
 EAR-0406751.
 Any opinions, findings, and conclusions or recommendations expressed in
 this material are those of the authors and do not necessarily reflect the
 views of the National Science Foundation.
 The code is being released under the GNU General Public License.
\end_layout

\begin_layout Chapter
Installation and Getting Help
\end_layout

\begin_layout Section
Getting Help and Reporting Bugs
\end_layout

\begin_layout Standard
For help, send an e-mail to the CIG Computational Science Mailing List 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

cig-cs@geodynamics.org
\end_layout

\end_inset

.
 You can subscribe to the 
\family typewriter
cig-cs
\family default
 mailing list and view archived discussions at the CIG Mail Lists web page
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

geodynamics.org/cig/lists
\end_layout

\end_inset

.
 If you encounter any bugs or have problems installing Cigma, please submit
 a report to the CIG Bug Tracker 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

geodynamics.org/bugs
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Installing from Source
\end_layout

\begin_layout Standard
In this section we discuss how to install each of the software libraries
 necessary for building Cigma.
 We recommend that you obtain binaries for these dpendencies from your package
 manager of choice, or from the corresponding website.
 When using a package manager, make sure to install the associated development
 headers along with the library, as these tend to be distributed separately
 from the library package itself.
\end_layout

\begin_layout Subsection
Quick Summary
\end_layout

\begin_layout Standard
After installing the necessary dependencies described below, download the
 source package from the CIG Cigma web page 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/software/packages/cs/cigma
\end_layout

\end_inset

.
 You will need the GNU C++ compiler for this step.
 Unpack the source tar file and issue the following commands
\end_layout

\begin_layout LyX-Code
$ tar xvfz cigma-1.0.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd cigma-1.0.0
\end_layout

\begin_layout LyX-Code
$ ./configure 
\backslash

\end_layout

\begin_layout LyX-Code
    --with-boost=$BOOST_PREFIX      
\backslash

\end_layout

\begin_layout LyX-Code
    --with-hdf5=$HDF5_PREFIX        
\backslash

\end_layout

\begin_layout LyX-Code
    --with-netcdf=$NETCDF_PREFIX    
\backslash

\end_layout

\begin_layout LyX-Code
    --with-vtk=$VTK_PREFIX          
\backslash

\end_layout

\begin_layout LyX-Code
    --with-vtk-version=$VTK_VERSION 
\backslash

\end_layout

\begin_layout LyX-Code
    --with-cppunit-prefix=$CPPUNIT_PREFIX
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
The Boost and HDF5 libraries are the only required components for this step.
 The installation prefixes should be used if you have installed the correspondin
g library in a custom location.
 In the instructions below, we use a subdirectory of 
\family typewriter
$HOME/opt
\family default
 as the installation prefix, but you may change it to something else.
 After all these steps are complete, you should be able to run the 
\family typewriter
cigma
\family default
 binary and begin comparing arbitrary functions.
\end_layout

\begin_layout Subsection
Boost library
\end_layout

\begin_layout Standard
The Boost C++ libraries are a collection of peer-reviewed and open source
 libraries that extend the functionality of C++.
 Cigma uses Boost for its smart pointer facilities, lexical conversions,
 as well as for parsing command-line options, and for providing cross-platform
 filesystem operations.
 In order to build Boost with the necessary components used in Cigma, you
 can use the following commands
\end_layout

\begin_layout LyX-Code
$ tar xvfz boost_1_37_0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd boost_1_37_0
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/boost 
\backslash

\end_layout

\begin_layout LyX-Code
              --with-libraries=system,filesystem,program_options
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
Other components of Boost that need to be built can be chosen from the list
 generated by the command
\end_layout

\begin_layout LyX-Code
$ ./configure --show-libraries
\end_layout

\begin_layout Standard
and modifying the comma-delimited list passed to the 
\family typewriter
--with-libraries
\family default
 option when repeating the build procedure above.
 The next version of Cigma will include a Python extension module that will
 need the python component of Boost, but is currently not necessary.
\end_layout

\begin_layout Subsection
HDF5 library
\end_layout

\begin_layout Standard
The Hierarchical Data Format is a library and multi-object file format for
 the transfer of numerical data between computers.
 Cigma depends on the C++ API of the HDF5 library, so it is important to
 enable it when running the configure script below.
 You can obtain the latest source from The HDF Group 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

hdfgroup.org/HDF5
\end_layout

\end_inset

, and use the following sequence of commands to build the library.
 
\end_layout

\begin_layout LyX-Code
$ tar xvfz hdf5-1.8.2.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd hdf5-1.8.2
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/hdf5-1.8.2 
\backslash

\end_layout

\begin_layout LyX-Code
              --with-zlib=$ZLIB_PREFIX      
\backslash

\end_layout

\begin_layout LyX-Code
              --enable-cxx
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
If it is not already available on your system, you must build the zlib compressi
on library before building HDF5 above 
\end_layout

\begin_layout LyX-Code
$ tar xvfz zlib-1.2.3.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd zlib-1.2.3
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/hdf5-1.8.2
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
In practice, you only need to do this if your system is missing the zlib
 development headers and you are unable to install them otherwise.
\end_layout

\begin_layout Standard
Alternatively, compiled binaries for the HDF5 library can be obtained at
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

hdfgroup.org/HDF5/release/obtain5.html
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
NetCDF library
\end_layout

\begin_layout Standard
NetCDF (Network Common Data Form) is a set of software libraries and machine-ind
ependent data formats that support the creation, access, and sharing of
 array-oriented scientific data.
 The source for
\end_layout

\begin_layout LyX-Code
$ tar xvfz netcdf-4.0
\end_layout

\begin_layout LyX-Code
$ cd netcdf-4.0
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/netcdf-4.0    
\backslash

\end_layout

\begin_layout LyX-Code
              --with-hdf5=$HOME/opt/hdf5-1.8.2 
\backslash

\end_layout

\begin_layout LyX-Code
              --enable-netcdf-4
\end_layout

\begin_layout LyX-Code
              
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
You may also 
\end_layout

\begin_layout Subsection
VTK library
\end_layout

\begin_layout Standard
The Visualization Toolkit (VTK) library is a popular open source graphics
 library for scientific visualizations.
 Cigma will need to be configured with the VTK library if you plan to directly
 specify your functions by using the VTK file format.
 The source for the VTK library is available from Kitware, Inc.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.vtk.org/get-software.php
\end_layout

\end_inset

.
 You will also need the CMake build environment, available from CMake 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

cmake.org
\end_layout

\end_inset

.
 After downloading the source package for the VTK library, you can issue
 the following commands
\end_layout

\begin_layout LyX-Code
$ tar xvfz vtk-5.2.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd VTK
\end_layout

\begin_layout LyX-Code
$ mkdir build
\end_layout

\begin_layout LyX-Code
$ cd build
\end_layout

\begin_layout LyX-Code
$ ccmake ..
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
The installation prefix and other settings can be changed during the 
\family typewriter
ccmake
\family default
 step above.
 By default, the installation prefix will point to the 
\family typewriter
/usr/local
\family default
 directory, but you may want to change it to a location like 
\family typewriter
$HOME/opt/vtk-5.2
\family default
 in case you would like to manage multiple versions of the VTK library in
 the same system.
\end_layout

\begin_layout Subsection
CppUnit library
\end_layout

\begin_layout Standard
CppUnit is a C++ unit testing framework used by Cigma for automatically
 running various internal consistency checks during every build.
 You will need this library if you want to modify the Cigma source and want
 to make certain guarantees about your additions to the code.
 After obtaining the obtaining the latest source release, you may build
 CppUnit by using the following sequence of steps.
\end_layout

\begin_layout LyX-Code
$ tar xvfz cppunit-1.21.1.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd cppunit-1.21.1
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=$HOME/opt/cppunit-1.21.1
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout LyX-Code
$ make install
\end_layout

\begin_layout Standard
CppUnit is available for download from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

sourceforge.net/projects/cppunit/
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Installing from the Software Repository
\end_layout

\begin_layout Standard
The Cigma source code is available via the CIG Subversion Repository 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

geodynamics.org/cig/software/Repository
\end_layout

\end_inset

.
 For this section, you will need an Subversion client, as well as the GNU
 tools Autoconf, Automake, and Libtool.
 To check if you have a Subversion client installed, type 
\family typewriter
svn
\family default
 and look for a usage message
\end_layout

\begin_layout LyX-Code
$ svn
\end_layout

\begin_layout LyX-Code
Type 'svn help' for usage.
\end_layout

\begin_layout Standard
To check for the presence of the GNU Autotools, use the following commands
\end_layout

\begin_layout LyX-Code
$ autoconf --version
\end_layout

\begin_layout LyX-Code
$ automake --version
\end_layout

\begin_layout LyX-Code
$ libtoolize --version
\end_layout

\begin_layout Standard
Using the source repository directly is recommended for users who want to
 extend Cigma 
\end_layout

\begin_layout Subsection
Downloading the Cigma Source
\end_layout

\begin_layout Standard
You may check out the latest version of Cigma by using the 
\family typewriter
svn checkout
\family default
 command:
\end_layout

\begin_layout LyX-Code
$ svn checkout http://geodynamics.org/svn/cig/cs/cigma/trunk cigma
\end_layout

\begin_layout Standard
This will create the local directory 
\family typewriter
cigma
\family default
 and fill it with the latest Cigma source from the CIG software repository.
 This new directory is called a 
\emph on
working copy
\emph default
.
 To merge the latest changes on your working copy, use the 
\family typewriter
svn update
\family default
 command:
\end_layout

\begin_layout LyX-Code
$ cd cigma
\end_layout

\begin_layout LyX-Code
$ svn update
\end_layout

\begin_layout Standard
This will preserve any local changes you have made to your working copy.
\end_layout

\begin_layout Subsection
Using the GNU Build System
\end_layout

\begin_layout Standard
Once you have obtained a working copy of the Cigma source, you will need
 to use the GNU Autotools to generate the appropriate build files.
 This can be accomplished by running the command 
\family typewriter
autoreconf -fi
\family default
:
\end_layout

\begin_layout LyX-Code
$ cd cigma
\end_layout

\begin_layout LyX-Code
$ autoreconf -fi
\end_layout

\begin_layout LyX-Code
$ ./configure <
\emph on
necessary-flags-here
\emph default
>
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout Standard
The 
\family typewriter
autoreconf
\family default
 tool generates the 
\family typewriter
configure
\family default
 script from the 
\family typewriter
configure.ac
\family default
 file.
 It also runs Automake to generate 
\family typewriter
Makefile.in
\family default
 from 
\family typewriter
Makefile.am
\family default
 in each source directory.
 After running 
\family typewriter
autoreconf
\family default
, you may install Cigma as described in Section 2.2 earlier in this Chapter.
\end_layout

\begin_layout Chapter
Running Cigma
\end_layout

\begin_layout Standard
Cigma is primarily designed for calculating error estimates between arbitrary
 functions.
 As such, the basic command line operation for comparing two functions takes
 the following form:
\end_layout

\begin_layout LyX-Code
$ cigma compare 
\series bold
\bar under
FunctionA
\series default
\bar default
 
\series bold
\bar under
FunctionB
\series default
\bar default
 -m 
\series bold
\bar under
IntegrationMesh
\series default
\bar default
 -o 
\series bold
\bar under
LocalResiduals
\end_layout

\begin_layout Standard
This command will compute local and global error metrics for the difference
 between two functions specified on the command line.
 Typically, you will also want to specify a particular discretization to
 use as the integration mesh.
 The output file will be used to store the results of the comparison, which
 are defined relative to the integration mesh.
 Here we give a general overview of the options used in Cigma, and show
 actual usage examples in the next Chapter.
\end_layout

\begin_layout Section
How to Select Your Input and Output Datasets
\end_layout

\begin_layout Standard
The basic objects used to store data in Cigma are simple two dimensional
 array of values, or datasets.
 As scientific file formats are capable of storing multiple datasets, you
 will typically need a way to select a specific array on a given data file.
 Therefore, regardless of the context, the option arguments to Cigma are
 parsed consistently by following the 
\family typewriter
\series bold
Filename:Location
\family default
\series default
 convention.
 If the 
\emph on
filename
\emph default
 part unambiguously determines the target array, then the 
\emph on
location
\emph default
 part of the option argument may be omitted.
 Now, depending on how Cigma was configured during the build procedure,
 there are a number of different file formats available for specifying and
 storing your data.
 In this case, the file format will be derived directly from the 
\emph on
filename
\emph default
 extension.
 
\end_layout

\begin_layout Standard
The simplest format you can use is a simple text file (with extension 
\family typewriter
.dat
\family default
) containing a single array.
 The most flexible way to store your arrays will be to use an HDF5 file
 (with extension 
\family typewriter
.h5
\family default
), which will allow you to organize your arrays in a hierarchy, as well
 as attach metadata attributes explaining the role that each of those arrays
 will serve.
 In VTK files, arrays can be accessed through an a single identifier.
\end_layout

\begin_layout Section
Specifying a Mesh
\end_layout

\begin_layout Standard
A mesh is associated with three items of information: (1) geometrical informatio
n for a number of nodes defined on a global coordinate system, and (2) topologic
al information describing how those nodes are connected to each other to
 form elements, and (3) an element type associated with the cell.
 In Cigma, these items are determined by the following command line options,
 arranged in tabular format for easy reference.
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\bar under
MeshA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\bar under
MeshB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\bar under
IntegrationMesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Items Read
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--first-mesh
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--second-mesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--mesh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(1,2,3)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--first-mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--second-mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--mesh-coords
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--first-mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--second-mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--mesh-connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--first-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--second-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--mesh-cell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(3)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Command Line Options
\end_layout

\begin_layout Standard
For any of the 
\bar under
MeshA
\bar default
, 
\bar under
MeshB
\bar default
, 
\bar under
IntegrationMesh
\bar default
 columns in the table above, the relationship between these options is as
 follows:
\end_layout

\begin_layout Enumerate
If option (M) is given, then options (M1) and (M2) are forbidden.
\end_layout

\begin_layout Enumerate
If option (M) is missing, then both options (M1) and (M2) must be specified.
\end_layout

\begin_layout Enumerate
Option (MC) can be deduced from option (M)
\end_layout

\begin_layout Enumerate
Option (MC) is required if options (M1) and (M2) are given.
\end_layout

\begin_layout Subsection
Mesh HDF5 File
\end_layout

\begin_layout Standard
When using an HDF5 file to store the mesh information, the 
\emph on
location
\emph default
 associated with option (M) must point to an HDF5 group that contains two
 arrays with the relevant mesh information.
 The names of those two arrays must be 
\family typewriter
\series bold
coordinates
\family default
\series default
 and 
\family typewriter
\series bold
connectivity
\family default
\series default
.
 If the 
\emph on
location
\emph default
 is empty, as is the case when only 
\emph on
filename
\emph default
 is specified, then the HDF5 group is assumed to be the root group 
\family typewriter
/
\family default
 of the hierarchy.
 Lastly, the option (MC) can be omitted if the HDF5 group has an attribute
 called 
\family typewriter
\series bold
\emph on
CellType
\family default
\series default
\emph default
 with a correct value.
 
\end_layout

\begin_layout LyX-Code

\emph on
Group location
\end_layout

\begin_layout LyX-Code
 |-- 
\emph on
Attribute
\emph default
 
\series bold
\emph on
CellType
\end_layout

\begin_layout LyX-Code
 |-- 
\emph on
Array
\emph default
 
\series bold
coordinates
\end_layout

\begin_layout LyX-Code
 `-- 
\emph on
Array
\emph default
 
\series bold
connectivity
\end_layout

\begin_layout Standard
Alternatively, one may specify options (M1) and (M2) separately by pointing
 directly to the arrays corresponding to the coordinates and connectivity
 information.
 The node ordering on the connectivity dataset is described in Appendix
 A.
\end_layout

\begin_layout Subsection
Mesh From a VTK File
\end_layout

\begin_layout Standard
Specifying a mesh by using a vtk files is very convenient, since we can
 simply pass the 
\emph on
filename
\emph default
 to (M).
 No 
\emph on
location
\emph default
 needs to be specified since all the appropriate mesh information can be
 read implicitly from the 
\family typewriter
POINTS
\family default
, and 
\family typewriter
CELLS
\family default
 datasets, which are required by the VTK file format.
 The value of (MC) is determined from the 
\family typewriter
CELL_TYPES
\family default
 dataset, which is also required.
\end_layout

\begin_layout Subsection
Mesh from a CUBIT ExodusII File
\end_layout

\begin_layout Standard
Another convenient way to specify a mesh is to use an ExodusII file created
 by the CUBIT mesh generation toolkit.
 In this case, the mesh file is natively in the NetCDF format.
 Again, it suffices to simply pass 
\emph on
filename
\emph default
 to option (M), and the appropriate mesh information will be read from the
 file.
 Currently, only the first element block is used.
 The value of (MC) is determined from the NetCDF string attribute 
\family typewriter
elem_type
\family default
 attached to the NetCDF integer variable called 
\family typewriter
connect1
\family default
.
\end_layout

\begin_layout Subsection
Mesh from Text Files
\end_layout

\begin_layout Standard
When using a text files, all three options (M1), (M2), and (MC) must be
 specified.
\end_layout

\begin_layout Subsection
Mesh Cell Shapes
\end_layout

\begin_layout Standard
The option (MC) can have a limited number of values, listed below.
\end_layout

\begin_layout Section
Specifying an Integration Mesh
\end_layout

\begin_layout Standard
An integration mesh can be specified by the command line options in Section
 3.2, subject to the following rules
\end_layout

\begin_layout Enumerate
At least one of 
\bar under
MeshA
\bar default
, 
\bar under
MeshB
\bar default
, or 
\bar under
IntegrationMesh
\bar default
 must be given.
\end_layout

\begin_layout Enumerate
If 
\bar under
IntegrationMesh
\bar default
 is specified, then it is always used.
\end_layout

\begin_layout Enumerate
If 
\bar under
IntegrationMesh
\bar default
 is missing, then 
\bar under
MeshA
\bar default
 is copied to 
\bar under
IntegrationMesh
\bar default
.
\end_layout

\begin_layout Enumerate
If only 
\bar under
MeshB
\bar default
 is given, then it is copied to 
\bar under
IntegrationMesh
\bar default
.
\end_layout

\begin_layout Standard
Now, deciding if a given mesh is adequate for accurately capturing the error
 in the comparison will depend on the functions being compared.
 One strategy to ensure an adequate mesh would be to take the discretization
 cells on which the error metric exceeds a certain threshold, mark those
 cells for refinement, and recalculate the residuals over the new discretization
, repeating the process if necessary.
 This strategy could be implemented on top of Cigma as a series of post-processi
ng steps by writing a suitable program or script that repeats this refinement
 process until the variations in the global error metric are small enough.
\end_layout

\begin_layout Standard
A second strategy would be to increase the order of the quadrature rule
 that we associate with the cells in the integration mesh.
 This has the advantage that we.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IntegrationRule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule-points
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--rule-weights
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Specifying the Functions
\end_layout

\begin_layout Standard
The requirements on the kind of functions that Cigma will accept are actually
 quite stringent.
 Recall from Chapter 1 that computing the local error metric involves approximat
ing a local error integral by a finite weighed sum over specific quadrature
 points.
 If we allow arbitrary meshes for the integration procedure, that means
 that we must be able to evaluate our functions wherever those quadrature
 points may lie.
 This implies that our functions must be capable of evaluating on arbitrary
 points, which may not always be possible due to missing information, or
 it may be too inefficient without first building an appropriate spatial-index
 database.
\end_layout

\begin_layout Subsection
Command Line Arguments
\end_layout

\begin_layout Subsection
By Finite Elements
\end_layout

\begin_layout Standard
A finite element description of a function is associated with three items
 of information: (1) a finite set of local basis functions, (2) a discretization
 over which the function is locally approximated by those basis functions,
 and finally (3) the actual global list of coefficients that yield the closest
 approximation to the function.
 How these items are specified depends on the underlying file format used
 to store the finite element description to our function.
\end_layout

\begin_layout Subsubsection
Using an HDF5 File
\end_layout

\begin_layout Subsubsection
Using a VTK File
\end_layout

\begin_layout Subsubsection
Using a Text File
\end_layout

\begin_layout Standard
Alternatively, you can also specify all arrays explicitly from a text file.
\end_layout

\begin_layout Subsection
By an Explicit Function
\end_layout

\begin_layout Standard
Sometimes you will be able to express a function in terms of a general formula
 or algorithm, in which case would like to be able to refer to such a function
 by using a simple name when specifying either of the 
\bar under
FunctionA
\bar default
 or 
\bar under
FunctionB
\bar default
 arguments.
 Currently in Cigma, this is accomplished in two major steps.
\end_layout

\begin_layout Enumerate
Start by implementing your function or algorithm as a C++ subclass of 
\family typewriter
cigma::Function
\family default
.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Simple examples are available in the 
\family typewriter
src/fn_*.cpp
\family default
 source files.
\end_layout

\begin_layout Enumerate
If you decide to link against a shared library containing your implementation,
 you will need to make the appropriate modifications to the 
\family typewriter
cigma_LDFLAGS
\family default
 and 
\family typewriter
cigma_CPPFLAGS
\family default
 automake variables in the 
\family typewriter
Makefile.am
\family default
 file.
\end_layout

\end_deeper
\begin_layout Enumerate
Next, register your new function under a unique name in the appropriate
 section of the 
\family typewriter
src/FunctionRegistry.cpp
\family default
 source file.
\end_layout

\begin_deeper
\begin_layout Enumerate
Follow the examples already shown in the implementation of the constructor
 
\family typewriter
cigma::FunctionRegistry
\family default
.
\end_layout

\end_deeper
\begin_layout Standard
Defining your own functions is ideal for analytic functions that other people
 downloading Cigma can use as benchmarks.
\end_layout

\begin_layout Subsection
By an Explicit List of Values
\end_layout

\begin_layout Standard
Registering an analytic function is not always convenient, since you will
 have to rebuild the 
\family typewriter
cigma
\family default
 executable every time you wish to add a new function, or modify an existing
 one.
 Unless you are working on defining a function that will be used repeatedly,
 you will probably find it easier to first calculate the required evaluation
 points, evaluate your function on those points by using a separate program
 or script, and then feed the values directly as one of the functions.
\end_layout

\begin_layout Standard
The only disadvantage of this approach is the number of evaluation points
 may be large.
 Moreover, this large number of evaluation points will be tied to a single
 integration mesh.
\end_layout

\begin_layout Section
Visualizing the Local 
\begin_inset Formula $L^{2}$
\end_inset

 Residuals
\end_layout

\begin_layout Standard
There are three possible output formats for the local residuals.
 
\end_layout

\begin_layout Standard
Once you've obtained the visualization file
\end_layout

\begin_layout Section
Other command line options
\end_layout

\begin_layout Standard
The full list of options can be obtained by running the following command:
\end_layout

\begin_layout LyX-Code
$ cigma compare --help
\end_layout

\begin_layout LyX-Code
Usage: cigma compare <FIRST-FIELD> <SECOND-FIELD> -o <RESIDUAL-FILE>
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Compare Options:    
\end_layout

\begin_layout LyX-Code
  -a [ --first ] arg    Path to first field
\end_layout

\begin_layout LyX-Code
  -b [ --second ] arg   Path to second field
\end_layout

\begin_layout LyX-Code
  -o [ --output ] arg   Output file (for residuals)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Detailed Options:
\end_layout

\begin_layout LyX-Code
  --first-mesh arg             Mesh for first field
\end_layout

\begin_layout LyX-Code
  --first-mesh-cell arg        ...cell type for first mesh
\end_layout

\begin_layout LyX-Code
  --first-mesh-coords arg      ...node coordinates for first mesh
\end_layout

\begin_layout LyX-Code
  --first-mesh-connect arg     ...connectivity for first mesh
\end_layout

\begin_layout LyX-Code
  --second-mesh arg            Mesh for second field
\end_layout

\begin_layout LyX-Code
  --second-mesh-cell arg       ...cell type for second mesh
\end_layout

\begin_layout LyX-Code
  --second-mesh-coords arg     ...node coordinates for second mesh
\end_layout

\begin_layout LyX-Code
  --second-mesh-connect arg    ...connectivity for second mesh
\end_layout

\begin_layout LyX-Code
  -m [ --mesh ] arg            Path to integration mesh
\end_layout

\begin_layout LyX-Code
  -c [ --mesh-cell ] arg       ...cell type of integration mesh
\end_layout

\begin_layout LyX-Code
  --mesh-coords arg            ...node coordinates of integration mesh
\end_layout

\begin_layout LyX-Code
  --mesh-connect arg           ...connectivity of integration mesh
\end_layout

\begin_layout LyX-Code
  -r [ --rule ] arg            Integration rule (points and weights)
\end_layout

\begin_layout LyX-Code
  --rule-weights arg           ...integration weights on reference cell
\end_layout

\begin_layout LyX-Code
  --rule-points arg            ...integration points on reference cell
\end_layout

\begin_layout LyX-Code
  --do-not-overwrite           Do NOT overwrite existing data
\end_layout

\begin_layout LyX-Code
  -f [ --timer-frequency ] arg Output frequency of timer
\end_layout

\begin_layout LyX-Code
  --global-threshold arg       Threshold value for global residual
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Other Options:
\end_layout

\begin_layout LyX-Code
  -h [ --help ]         produce help message
\end_layout

\begin_layout LyX-Code
  -v [ --verbose ]      produce verbose output 
\end_layout

\begin_layout Chapter
Examples
\end_layout

\begin_layout Section
Short-Term Tectonics
\end_layout

\begin_layout Section
Long-Term Tectonics
\end_layout

\begin_layout Section
Mantle Convection
\end_layout

\begin_layout Chapter
Troubleshooting
\end_layout

\begin_layout Standard
It is possible that.
\end_layout

\begin_layout Section
Mesh
\end_layout

\begin_layout Section
Finite Elements
\end_layout

\begin_layout Chapter
\start_of_appendix
Input and Output Formats
\end_layout

\begin_layout Section
Supported File Formats
\end_layout

\begin_layout Standard
Cigma can understand a number of file formats, depending on how it is configured
 (see Chapter 2).
 By default it will read and write all information in binary form as HDF5
 files, which is optimal for archiving data with minimal redundancy.
 VTK files are also sometimes used by finite element software, due to the
 ease with which the solution fields can be visualized.
 Lastly, ExodusII mesh files generated by the CUBIT mesh generation package
 can also be read from Cigma.
\end_layout

\begin_layout Section
Input Quantities
\end_layout

\begin_layout Section
Output Quantities
\end_layout

\begin_layout Chapter
Mesh Format
\end_layout

\begin_layout Standard
In this chapter we describe the mesh format used to store meshes.
\end_layout

\begin_layout Section
Element Types
\end_layout

\begin_layout Standard
Individual blocks, we assume that within the block we have a single element
 type, chosen from this list.
\end_layout

\begin_layout Description
CellType Defines the geometrical type of the reference element associated
 with the Element Block
\end_layout

\begin_deeper
\begin_layout Description
tri3 Three-node triangle.
\end_layout

\begin_layout Description
tri6 Six-node second order triangle.
 Three nodes associated with the vertices, and three with the edges.
\end_layout

\begin_layout Description
quad4 Four-node quadrangle.
\end_layout

\begin_layout Description
quad8 Eight-node second order quadrangle.
 Four nodes associated with the vertices, four with the edges, and one with
 the face.
\end_layout

\begin_layout Description
tet4 Four-node tetrahedron.
\end_layout

\begin_layout Description
tet10 Ten-node second order tetrahedron.
 Four nodes associated with the vertices, and six with the edges.
\end_layout

\begin_layout Description
hex8 Eight-node hexahedron.
\end_layout

\begin_layout Description
hex20 A 20-node second order hexahedron.
 Eight nodes associated with the vertices and twelve with the edges.
\end_layout

\begin_layout Description
hex27 A 27-node second order hexahedron.
 Eight nodes associated with the vertices, twelve with the edges, six with
 the faces, and one with the volume.
\end_layout

\end_deeper
\begin_layout Section
Node Ordering
\end_layout

\begin_layout Standard
The ordering of the columns in the connectivity array corresponds to the
 node ordering.
 The reference elements are defined as follows
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
XXX: Convert the svg files and insert them here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The numbering for the face and volume internal nodes is recursive, i.e., the
 numbering follows that of an embedded face or volume.
\end_layout

\begin_layout Chapter
Quadrature Rules
\end_layout

\begin_layout Standard
Here we discuss the quadrature rules available in Cigma.
\end_layout

\begin_layout Chapter
Utilities
\end_layout

\begin_layout Standard
Cigma comes with a couple of utilities that make the life easier to the
 user.
 One is called 
\family typewriter
h5attr
\family default
 and lets you see the attributes attached to a dataset inside an HDF5 file.
 The other one is called 
\family typewriter
vtk-residuals
\family default
 and allows the user to create visualization files given a mesh and a scalar
 array representing the residuals over the elements of the mesh.
\end_layout

\begin_layout Standard
Normally, these utilities will be installed somewhere in your PATH during
 the process of installation of the Cigma package, so that you can invoke
 them from any place in your filesystem after the installation has successfully
 finished.
\end_layout

\end_body
\end_document
